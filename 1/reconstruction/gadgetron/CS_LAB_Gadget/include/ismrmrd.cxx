// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ismrmrd.hxx"

namespace ISMRMRD
{
  // ismrmrdHeader
  // 

  const ismrmrdHeader::subjectInformation_optional& ismrmrdHeader::
  subjectInformation () const
  {
    return this->subjectInformation_;
  }

  ismrmrdHeader::subjectInformation_optional& ismrmrdHeader::
  subjectInformation ()
  {
    return this->subjectInformation_;
  }

  void ismrmrdHeader::
  subjectInformation (const subjectInformation_type& x)
  {
    this->subjectInformation_.set (x);
  }

  void ismrmrdHeader::
  subjectInformation (const subjectInformation_optional& x)
  {
    this->subjectInformation_ = x;
  }

  void ismrmrdHeader::
  subjectInformation (::std::auto_ptr< subjectInformation_type > x)
  {
    this->subjectInformation_.set (x);
  }

  const ismrmrdHeader::studyInformation_optional& ismrmrdHeader::
  studyInformation () const
  {
    return this->studyInformation_;
  }

  ismrmrdHeader::studyInformation_optional& ismrmrdHeader::
  studyInformation ()
  {
    return this->studyInformation_;
  }

  void ismrmrdHeader::
  studyInformation (const studyInformation_type& x)
  {
    this->studyInformation_.set (x);
  }

  void ismrmrdHeader::
  studyInformation (const studyInformation_optional& x)
  {
    this->studyInformation_ = x;
  }

  void ismrmrdHeader::
  studyInformation (::std::auto_ptr< studyInformation_type > x)
  {
    this->studyInformation_.set (x);
  }

  const ismrmrdHeader::measurementInformation_optional& ismrmrdHeader::
  measurementInformation () const
  {
    return this->measurementInformation_;
  }

  ismrmrdHeader::measurementInformation_optional& ismrmrdHeader::
  measurementInformation ()
  {
    return this->measurementInformation_;
  }

  void ismrmrdHeader::
  measurementInformation (const measurementInformation_type& x)
  {
    this->measurementInformation_.set (x);
  }

  void ismrmrdHeader::
  measurementInformation (const measurementInformation_optional& x)
  {
    this->measurementInformation_ = x;
  }

  void ismrmrdHeader::
  measurementInformation (::std::auto_ptr< measurementInformation_type > x)
  {
    this->measurementInformation_.set (x);
  }

  const ismrmrdHeader::acquisitionSystemInformation_optional& ismrmrdHeader::
  acquisitionSystemInformation () const
  {
    return this->acquisitionSystemInformation_;
  }

  ismrmrdHeader::acquisitionSystemInformation_optional& ismrmrdHeader::
  acquisitionSystemInformation ()
  {
    return this->acquisitionSystemInformation_;
  }

  void ismrmrdHeader::
  acquisitionSystemInformation (const acquisitionSystemInformation_type& x)
  {
    this->acquisitionSystemInformation_.set (x);
  }

  void ismrmrdHeader::
  acquisitionSystemInformation (const acquisitionSystemInformation_optional& x)
  {
    this->acquisitionSystemInformation_ = x;
  }

  void ismrmrdHeader::
  acquisitionSystemInformation (::std::auto_ptr< acquisitionSystemInformation_type > x)
  {
    this->acquisitionSystemInformation_.set (x);
  }

  const ismrmrdHeader::experimentalConditions_type& ismrmrdHeader::
  experimentalConditions () const
  {
    return this->experimentalConditions_.get ();
  }

  ismrmrdHeader::experimentalConditions_type& ismrmrdHeader::
  experimentalConditions ()
  {
    return this->experimentalConditions_.get ();
  }

  void ismrmrdHeader::
  experimentalConditions (const experimentalConditions_type& x)
  {
    this->experimentalConditions_.set (x);
  }

  void ismrmrdHeader::
  experimentalConditions (::std::auto_ptr< experimentalConditions_type > x)
  {
    this->experimentalConditions_.set (x);
  }

  const ismrmrdHeader::encoding_sequence& ismrmrdHeader::
  encoding () const
  {
    return this->encoding_;
  }

  ismrmrdHeader::encoding_sequence& ismrmrdHeader::
  encoding ()
  {
    return this->encoding_;
  }

  void ismrmrdHeader::
  encoding (const encoding_sequence& s)
  {
    this->encoding_ = s;
  }

  const ismrmrdHeader::parallelImaging_optional& ismrmrdHeader::
  parallelImaging () const
  {
    return this->parallelImaging_;
  }

  ismrmrdHeader::parallelImaging_optional& ismrmrdHeader::
  parallelImaging ()
  {
    return this->parallelImaging_;
  }

  void ismrmrdHeader::
  parallelImaging (const parallelImaging_type& x)
  {
    this->parallelImaging_.set (x);
  }

  void ismrmrdHeader::
  parallelImaging (const parallelImaging_optional& x)
  {
    this->parallelImaging_ = x;
  }

  void ismrmrdHeader::
  parallelImaging (::std::auto_ptr< parallelImaging_type > x)
  {
    this->parallelImaging_.set (x);
  }

  const ismrmrdHeader::sequenceParameters_optional& ismrmrdHeader::
  sequenceParameters () const
  {
    return this->sequenceParameters_;
  }

  ismrmrdHeader::sequenceParameters_optional& ismrmrdHeader::
  sequenceParameters ()
  {
    return this->sequenceParameters_;
  }

  void ismrmrdHeader::
  sequenceParameters (const sequenceParameters_type& x)
  {
    this->sequenceParameters_.set (x);
  }

  void ismrmrdHeader::
  sequenceParameters (const sequenceParameters_optional& x)
  {
    this->sequenceParameters_ = x;
  }

  void ismrmrdHeader::
  sequenceParameters (::std::auto_ptr< sequenceParameters_type > x)
  {
    this->sequenceParameters_.set (x);
  }

  const ismrmrdHeader::dicomParameters_optional& ismrmrdHeader::
  dicomParameters () const
  {
    return this->dicomParameters_;
  }

  ismrmrdHeader::dicomParameters_optional& ismrmrdHeader::
  dicomParameters ()
  {
    return this->dicomParameters_;
  }

  void ismrmrdHeader::
  dicomParameters (const dicomParameters_type& x)
  {
    this->dicomParameters_.set (x);
  }

  void ismrmrdHeader::
  dicomParameters (const dicomParameters_optional& x)
  {
    this->dicomParameters_ = x;
  }

  void ismrmrdHeader::
  dicomParameters (::std::auto_ptr< dicomParameters_type > x)
  {
    this->dicomParameters_.set (x);
  }

  const ismrmrdHeader::userParameters_optional& ismrmrdHeader::
  userParameters () const
  {
    return this->userParameters_;
  }

  ismrmrdHeader::userParameters_optional& ismrmrdHeader::
  userParameters ()
  {
    return this->userParameters_;
  }

  void ismrmrdHeader::
  userParameters (const userParameters_type& x)
  {
    this->userParameters_.set (x);
  }

  void ismrmrdHeader::
  userParameters (const userParameters_optional& x)
  {
    this->userParameters_ = x;
  }

  void ismrmrdHeader::
  userParameters (::std::auto_ptr< userParameters_type > x)
  {
    this->userParameters_.set (x);
  }


  // subjectInformationType
  // 

  const subjectInformationType::patientName_optional& subjectInformationType::
  patientName () const
  {
    return this->patientName_;
  }

  subjectInformationType::patientName_optional& subjectInformationType::
  patientName ()
  {
    return this->patientName_;
  }

  void subjectInformationType::
  patientName (const patientName_type& x)
  {
    this->patientName_.set (x);
  }

  void subjectInformationType::
  patientName (const patientName_optional& x)
  {
    this->patientName_ = x;
  }

  void subjectInformationType::
  patientName (::std::auto_ptr< patientName_type > x)
  {
    this->patientName_.set (x);
  }

  const subjectInformationType::patientWeight_kg_optional& subjectInformationType::
  patientWeight_kg () const
  {
    return this->patientWeight_kg_;
  }

  subjectInformationType::patientWeight_kg_optional& subjectInformationType::
  patientWeight_kg ()
  {
    return this->patientWeight_kg_;
  }

  void subjectInformationType::
  patientWeight_kg (const patientWeight_kg_type& x)
  {
    this->patientWeight_kg_.set (x);
  }

  void subjectInformationType::
  patientWeight_kg (const patientWeight_kg_optional& x)
  {
    this->patientWeight_kg_ = x;
  }

  const subjectInformationType::patientID_optional& subjectInformationType::
  patientID () const
  {
    return this->patientID_;
  }

  subjectInformationType::patientID_optional& subjectInformationType::
  patientID ()
  {
    return this->patientID_;
  }

  void subjectInformationType::
  patientID (const patientID_type& x)
  {
    this->patientID_.set (x);
  }

  void subjectInformationType::
  patientID (const patientID_optional& x)
  {
    this->patientID_ = x;
  }

  void subjectInformationType::
  patientID (::std::auto_ptr< patientID_type > x)
  {
    this->patientID_.set (x);
  }

  const subjectInformationType::patientBirthdate_optional& subjectInformationType::
  patientBirthdate () const
  {
    return this->patientBirthdate_;
  }

  subjectInformationType::patientBirthdate_optional& subjectInformationType::
  patientBirthdate ()
  {
    return this->patientBirthdate_;
  }

  void subjectInformationType::
  patientBirthdate (const patientBirthdate_type& x)
  {
    this->patientBirthdate_.set (x);
  }

  void subjectInformationType::
  patientBirthdate (const patientBirthdate_optional& x)
  {
    this->patientBirthdate_ = x;
  }

  void subjectInformationType::
  patientBirthdate (::std::auto_ptr< patientBirthdate_type > x)
  {
    this->patientBirthdate_.set (x);
  }

  const subjectInformationType::patientGender_optional& subjectInformationType::
  patientGender () const
  {
    return this->patientGender_;
  }

  subjectInformationType::patientGender_optional& subjectInformationType::
  patientGender ()
  {
    return this->patientGender_;
  }

  void subjectInformationType::
  patientGender (const patientGender_type& x)
  {
    this->patientGender_.set (x);
  }

  void subjectInformationType::
  patientGender (const patientGender_optional& x)
  {
    this->patientGender_ = x;
  }

  void subjectInformationType::
  patientGender (::std::auto_ptr< patientGender_type > x)
  {
    this->patientGender_.set (x);
  }


  // studyInformationType
  // 

  const studyInformationType::studyDate_optional& studyInformationType::
  studyDate () const
  {
    return this->studyDate_;
  }

  studyInformationType::studyDate_optional& studyInformationType::
  studyDate ()
  {
    return this->studyDate_;
  }

  void studyInformationType::
  studyDate (const studyDate_type& x)
  {
    this->studyDate_.set (x);
  }

  void studyInformationType::
  studyDate (const studyDate_optional& x)
  {
    this->studyDate_ = x;
  }

  void studyInformationType::
  studyDate (::std::auto_ptr< studyDate_type > x)
  {
    this->studyDate_.set (x);
  }

  const studyInformationType::studyTime_optional& studyInformationType::
  studyTime () const
  {
    return this->studyTime_;
  }

  studyInformationType::studyTime_optional& studyInformationType::
  studyTime ()
  {
    return this->studyTime_;
  }

  void studyInformationType::
  studyTime (const studyTime_type& x)
  {
    this->studyTime_.set (x);
  }

  void studyInformationType::
  studyTime (const studyTime_optional& x)
  {
    this->studyTime_ = x;
  }

  void studyInformationType::
  studyTime (::std::auto_ptr< studyTime_type > x)
  {
    this->studyTime_.set (x);
  }

  const studyInformationType::studyID_optional& studyInformationType::
  studyID () const
  {
    return this->studyID_;
  }

  studyInformationType::studyID_optional& studyInformationType::
  studyID ()
  {
    return this->studyID_;
  }

  void studyInformationType::
  studyID (const studyID_type& x)
  {
    this->studyID_.set (x);
  }

  void studyInformationType::
  studyID (const studyID_optional& x)
  {
    this->studyID_ = x;
  }

  void studyInformationType::
  studyID (::std::auto_ptr< studyID_type > x)
  {
    this->studyID_.set (x);
  }

  const studyInformationType::accessionNumber_optional& studyInformationType::
  accessionNumber () const
  {
    return this->accessionNumber_;
  }

  studyInformationType::accessionNumber_optional& studyInformationType::
  accessionNumber ()
  {
    return this->accessionNumber_;
  }

  void studyInformationType::
  accessionNumber (const accessionNumber_type& x)
  {
    this->accessionNumber_.set (x);
  }

  void studyInformationType::
  accessionNumber (const accessionNumber_optional& x)
  {
    this->accessionNumber_ = x;
  }

  const studyInformationType::referringPhysicianName_optional& studyInformationType::
  referringPhysicianName () const
  {
    return this->referringPhysicianName_;
  }

  studyInformationType::referringPhysicianName_optional& studyInformationType::
  referringPhysicianName ()
  {
    return this->referringPhysicianName_;
  }

  void studyInformationType::
  referringPhysicianName (const referringPhysicianName_type& x)
  {
    this->referringPhysicianName_.set (x);
  }

  void studyInformationType::
  referringPhysicianName (const referringPhysicianName_optional& x)
  {
    this->referringPhysicianName_ = x;
  }

  void studyInformationType::
  referringPhysicianName (::std::auto_ptr< referringPhysicianName_type > x)
  {
    this->referringPhysicianName_.set (x);
  }

  const studyInformationType::studyDescription_optional& studyInformationType::
  studyDescription () const
  {
    return this->studyDescription_;
  }

  studyInformationType::studyDescription_optional& studyInformationType::
  studyDescription ()
  {
    return this->studyDescription_;
  }

  void studyInformationType::
  studyDescription (const studyDescription_type& x)
  {
    this->studyDescription_.set (x);
  }

  void studyInformationType::
  studyDescription (const studyDescription_optional& x)
  {
    this->studyDescription_ = x;
  }

  void studyInformationType::
  studyDescription (::std::auto_ptr< studyDescription_type > x)
  {
    this->studyDescription_.set (x);
  }


  // measurementInformationType
  // 

  const measurementInformationType::measurementID_optional& measurementInformationType::
  measurementID () const
  {
    return this->measurementID_;
  }

  measurementInformationType::measurementID_optional& measurementInformationType::
  measurementID ()
  {
    return this->measurementID_;
  }

  void measurementInformationType::
  measurementID (const measurementID_type& x)
  {
    this->measurementID_.set (x);
  }

  void measurementInformationType::
  measurementID (const measurementID_optional& x)
  {
    this->measurementID_ = x;
  }

  void measurementInformationType::
  measurementID (::std::auto_ptr< measurementID_type > x)
  {
    this->measurementID_.set (x);
  }

  const measurementInformationType::seriesDate_optional& measurementInformationType::
  seriesDate () const
  {
    return this->seriesDate_;
  }

  measurementInformationType::seriesDate_optional& measurementInformationType::
  seriesDate ()
  {
    return this->seriesDate_;
  }

  void measurementInformationType::
  seriesDate (const seriesDate_type& x)
  {
    this->seriesDate_.set (x);
  }

  void measurementInformationType::
  seriesDate (const seriesDate_optional& x)
  {
    this->seriesDate_ = x;
  }

  void measurementInformationType::
  seriesDate (::std::auto_ptr< seriesDate_type > x)
  {
    this->seriesDate_.set (x);
  }

  const measurementInformationType::seriesTime_optional& measurementInformationType::
  seriesTime () const
  {
    return this->seriesTime_;
  }

  measurementInformationType::seriesTime_optional& measurementInformationType::
  seriesTime ()
  {
    return this->seriesTime_;
  }

  void measurementInformationType::
  seriesTime (const seriesTime_type& x)
  {
    this->seriesTime_.set (x);
  }

  void measurementInformationType::
  seriesTime (const seriesTime_optional& x)
  {
    this->seriesTime_ = x;
  }

  void measurementInformationType::
  seriesTime (::std::auto_ptr< seriesTime_type > x)
  {
    this->seriesTime_.set (x);
  }

  const measurementInformationType::patientPosition_type& measurementInformationType::
  patientPosition () const
  {
    return this->patientPosition_.get ();
  }

  measurementInformationType::patientPosition_type& measurementInformationType::
  patientPosition ()
  {
    return this->patientPosition_.get ();
  }

  void measurementInformationType::
  patientPosition (const patientPosition_type& x)
  {
    this->patientPosition_.set (x);
  }

  void measurementInformationType::
  patientPosition (::std::auto_ptr< patientPosition_type > x)
  {
    this->patientPosition_.set (x);
  }

  const measurementInformationType::initialSeriesNumber_optional& measurementInformationType::
  initialSeriesNumber () const
  {
    return this->initialSeriesNumber_;
  }

  measurementInformationType::initialSeriesNumber_optional& measurementInformationType::
  initialSeriesNumber ()
  {
    return this->initialSeriesNumber_;
  }

  void measurementInformationType::
  initialSeriesNumber (const initialSeriesNumber_type& x)
  {
    this->initialSeriesNumber_.set (x);
  }

  void measurementInformationType::
  initialSeriesNumber (const initialSeriesNumber_optional& x)
  {
    this->initialSeriesNumber_ = x;
  }

  const measurementInformationType::protocolName_optional& measurementInformationType::
  protocolName () const
  {
    return this->protocolName_;
  }

  measurementInformationType::protocolName_optional& measurementInformationType::
  protocolName ()
  {
    return this->protocolName_;
  }

  void measurementInformationType::
  protocolName (const protocolName_type& x)
  {
    this->protocolName_.set (x);
  }

  void measurementInformationType::
  protocolName (const protocolName_optional& x)
  {
    this->protocolName_ = x;
  }

  void measurementInformationType::
  protocolName (::std::auto_ptr< protocolName_type > x)
  {
    this->protocolName_.set (x);
  }

  const measurementInformationType::seriesDescription_optional& measurementInformationType::
  seriesDescription () const
  {
    return this->seriesDescription_;
  }

  measurementInformationType::seriesDescription_optional& measurementInformationType::
  seriesDescription ()
  {
    return this->seriesDescription_;
  }

  void measurementInformationType::
  seriesDescription (const seriesDescription_type& x)
  {
    this->seriesDescription_.set (x);
  }

  void measurementInformationType::
  seriesDescription (const seriesDescription_optional& x)
  {
    this->seriesDescription_ = x;
  }

  void measurementInformationType::
  seriesDescription (::std::auto_ptr< seriesDescription_type > x)
  {
    this->seriesDescription_.set (x);
  }

  const measurementInformationType::measurementDependency_sequence& measurementInformationType::
  measurementDependency () const
  {
    return this->measurementDependency_;
  }

  measurementInformationType::measurementDependency_sequence& measurementInformationType::
  measurementDependency ()
  {
    return this->measurementDependency_;
  }

  void measurementInformationType::
  measurementDependency (const measurementDependency_sequence& s)
  {
    this->measurementDependency_ = s;
  }


  // measurementDependencyType
  // 

  const measurementDependencyType::dependencyType_type& measurementDependencyType::
  dependencyType () const
  {
    return this->dependencyType_.get ();
  }

  measurementDependencyType::dependencyType_type& measurementDependencyType::
  dependencyType ()
  {
    return this->dependencyType_.get ();
  }

  void measurementDependencyType::
  dependencyType (const dependencyType_type& x)
  {
    this->dependencyType_.set (x);
  }

  void measurementDependencyType::
  dependencyType (::std::auto_ptr< dependencyType_type > x)
  {
    this->dependencyType_.set (x);
  }

  const measurementDependencyType::measurementID_type& measurementDependencyType::
  measurementID () const
  {
    return this->measurementID_.get ();
  }

  measurementDependencyType::measurementID_type& measurementDependencyType::
  measurementID ()
  {
    return this->measurementID_.get ();
  }

  void measurementDependencyType::
  measurementID (const measurementID_type& x)
  {
    this->measurementID_.set (x);
  }

  void measurementDependencyType::
  measurementID (::std::auto_ptr< measurementID_type > x)
  {
    this->measurementID_.set (x);
  }


  // acquisitionSystemInformationType
  // 

  const acquisitionSystemInformationType::systemVendor_optional& acquisitionSystemInformationType::
  systemVendor () const
  {
    return this->systemVendor_;
  }

  acquisitionSystemInformationType::systemVendor_optional& acquisitionSystemInformationType::
  systemVendor ()
  {
    return this->systemVendor_;
  }

  void acquisitionSystemInformationType::
  systemVendor (const systemVendor_type& x)
  {
    this->systemVendor_.set (x);
  }

  void acquisitionSystemInformationType::
  systemVendor (const systemVendor_optional& x)
  {
    this->systemVendor_ = x;
  }

  void acquisitionSystemInformationType::
  systemVendor (::std::auto_ptr< systemVendor_type > x)
  {
    this->systemVendor_.set (x);
  }

  const acquisitionSystemInformationType::systemModel_optional& acquisitionSystemInformationType::
  systemModel () const
  {
    return this->systemModel_;
  }

  acquisitionSystemInformationType::systemModel_optional& acquisitionSystemInformationType::
  systemModel ()
  {
    return this->systemModel_;
  }

  void acquisitionSystemInformationType::
  systemModel (const systemModel_type& x)
  {
    this->systemModel_.set (x);
  }

  void acquisitionSystemInformationType::
  systemModel (const systemModel_optional& x)
  {
    this->systemModel_ = x;
  }

  void acquisitionSystemInformationType::
  systemModel (::std::auto_ptr< systemModel_type > x)
  {
    this->systemModel_.set (x);
  }

  const acquisitionSystemInformationType::systemFieldStrength_T_optional& acquisitionSystemInformationType::
  systemFieldStrength_T () const
  {
    return this->systemFieldStrength_T_;
  }

  acquisitionSystemInformationType::systemFieldStrength_T_optional& acquisitionSystemInformationType::
  systemFieldStrength_T ()
  {
    return this->systemFieldStrength_T_;
  }

  void acquisitionSystemInformationType::
  systemFieldStrength_T (const systemFieldStrength_T_type& x)
  {
    this->systemFieldStrength_T_.set (x);
  }

  void acquisitionSystemInformationType::
  systemFieldStrength_T (const systemFieldStrength_T_optional& x)
  {
    this->systemFieldStrength_T_ = x;
  }

  const acquisitionSystemInformationType::relativeReceiverNoiseBandwidth_optional& acquisitionSystemInformationType::
  relativeReceiverNoiseBandwidth () const
  {
    return this->relativeReceiverNoiseBandwidth_;
  }

  acquisitionSystemInformationType::relativeReceiverNoiseBandwidth_optional& acquisitionSystemInformationType::
  relativeReceiverNoiseBandwidth ()
  {
    return this->relativeReceiverNoiseBandwidth_;
  }

  void acquisitionSystemInformationType::
  relativeReceiverNoiseBandwidth (const relativeReceiverNoiseBandwidth_type& x)
  {
    this->relativeReceiverNoiseBandwidth_.set (x);
  }

  void acquisitionSystemInformationType::
  relativeReceiverNoiseBandwidth (const relativeReceiverNoiseBandwidth_optional& x)
  {
    this->relativeReceiverNoiseBandwidth_ = x;
  }

  const acquisitionSystemInformationType::receiverChannels_optional& acquisitionSystemInformationType::
  receiverChannels () const
  {
    return this->receiverChannels_;
  }

  acquisitionSystemInformationType::receiverChannels_optional& acquisitionSystemInformationType::
  receiverChannels ()
  {
    return this->receiverChannels_;
  }

  void acquisitionSystemInformationType::
  receiverChannels (const receiverChannels_type& x)
  {
    this->receiverChannels_.set (x);
  }

  void acquisitionSystemInformationType::
  receiverChannels (const receiverChannels_optional& x)
  {
    this->receiverChannels_ = x;
  }

  const acquisitionSystemInformationType::institutionName_optional& acquisitionSystemInformationType::
  institutionName () const
  {
    return this->institutionName_;
  }

  acquisitionSystemInformationType::institutionName_optional& acquisitionSystemInformationType::
  institutionName ()
  {
    return this->institutionName_;
  }

  void acquisitionSystemInformationType::
  institutionName (const institutionName_type& x)
  {
    this->institutionName_.set (x);
  }

  void acquisitionSystemInformationType::
  institutionName (const institutionName_optional& x)
  {
    this->institutionName_ = x;
  }

  void acquisitionSystemInformationType::
  institutionName (::std::auto_ptr< institutionName_type > x)
  {
    this->institutionName_.set (x);
  }

  const acquisitionSystemInformationType::stationName_optional& acquisitionSystemInformationType::
  stationName () const
  {
    return this->stationName_;
  }

  acquisitionSystemInformationType::stationName_optional& acquisitionSystemInformationType::
  stationName ()
  {
    return this->stationName_;
  }

  void acquisitionSystemInformationType::
  stationName (const stationName_type& x)
  {
    this->stationName_.set (x);
  }

  void acquisitionSystemInformationType::
  stationName (const stationName_optional& x)
  {
    this->stationName_ = x;
  }

  void acquisitionSystemInformationType::
  stationName (::std::auto_ptr< stationName_type > x)
  {
    this->stationName_.set (x);
  }


  // experimentalConditionsType
  // 

  const experimentalConditionsType::H1resonanceFrequency_Hz_type& experimentalConditionsType::
  H1resonanceFrequency_Hz () const
  {
    return this->H1resonanceFrequency_Hz_.get ();
  }

  experimentalConditionsType::H1resonanceFrequency_Hz_type& experimentalConditionsType::
  H1resonanceFrequency_Hz ()
  {
    return this->H1resonanceFrequency_Hz_.get ();
  }

  void experimentalConditionsType::
  H1resonanceFrequency_Hz (const H1resonanceFrequency_Hz_type& x)
  {
    this->H1resonanceFrequency_Hz_.set (x);
  }


  // encoding
  // 

  const encoding::encodedSpace_type& encoding::
  encodedSpace () const
  {
    return this->encodedSpace_.get ();
  }

  encoding::encodedSpace_type& encoding::
  encodedSpace ()
  {
    return this->encodedSpace_.get ();
  }

  void encoding::
  encodedSpace (const encodedSpace_type& x)
  {
    this->encodedSpace_.set (x);
  }

  void encoding::
  encodedSpace (::std::auto_ptr< encodedSpace_type > x)
  {
    this->encodedSpace_.set (x);
  }

  const encoding::reconSpace_type& encoding::
  reconSpace () const
  {
    return this->reconSpace_.get ();
  }

  encoding::reconSpace_type& encoding::
  reconSpace ()
  {
    return this->reconSpace_.get ();
  }

  void encoding::
  reconSpace (const reconSpace_type& x)
  {
    this->reconSpace_.set (x);
  }

  void encoding::
  reconSpace (::std::auto_ptr< reconSpace_type > x)
  {
    this->reconSpace_.set (x);
  }

  const encoding::encodingLimits_type& encoding::
  encodingLimits () const
  {
    return this->encodingLimits_.get ();
  }

  encoding::encodingLimits_type& encoding::
  encodingLimits ()
  {
    return this->encodingLimits_.get ();
  }

  void encoding::
  encodingLimits (const encodingLimits_type& x)
  {
    this->encodingLimits_.set (x);
  }

  void encoding::
  encodingLimits (::std::auto_ptr< encodingLimits_type > x)
  {
    this->encodingLimits_.set (x);
  }

  const encoding::trajectory_type& encoding::
  trajectory () const
  {
    return this->trajectory_.get ();
  }

  encoding::trajectory_type& encoding::
  trajectory ()
  {
    return this->trajectory_.get ();
  }

  void encoding::
  trajectory (const trajectory_type& x)
  {
    this->trajectory_.set (x);
  }

  void encoding::
  trajectory (::std::auto_ptr< trajectory_type > x)
  {
    this->trajectory_.set (x);
  }

  const encoding::trajectoryDescription_optional& encoding::
  trajectoryDescription () const
  {
    return this->trajectoryDescription_;
  }

  encoding::trajectoryDescription_optional& encoding::
  trajectoryDescription ()
  {
    return this->trajectoryDescription_;
  }

  void encoding::
  trajectoryDescription (const trajectoryDescription_type& x)
  {
    this->trajectoryDescription_.set (x);
  }

  void encoding::
  trajectoryDescription (const trajectoryDescription_optional& x)
  {
    this->trajectoryDescription_ = x;
  }

  void encoding::
  trajectoryDescription (::std::auto_ptr< trajectoryDescription_type > x)
  {
    this->trajectoryDescription_.set (x);
  }


  // encodingSpaceType
  // 

  const encodingSpaceType::matrixSize_type& encodingSpaceType::
  matrixSize () const
  {
    return this->matrixSize_.get ();
  }

  encodingSpaceType::matrixSize_type& encodingSpaceType::
  matrixSize ()
  {
    return this->matrixSize_.get ();
  }

  void encodingSpaceType::
  matrixSize (const matrixSize_type& x)
  {
    this->matrixSize_.set (x);
  }

  void encodingSpaceType::
  matrixSize (::std::auto_ptr< matrixSize_type > x)
  {
    this->matrixSize_.set (x);
  }

  const encodingSpaceType::fieldOfView_mm_type& encodingSpaceType::
  fieldOfView_mm () const
  {
    return this->fieldOfView_mm_.get ();
  }

  encodingSpaceType::fieldOfView_mm_type& encodingSpaceType::
  fieldOfView_mm ()
  {
    return this->fieldOfView_mm_.get ();
  }

  void encodingSpaceType::
  fieldOfView_mm (const fieldOfView_mm_type& x)
  {
    this->fieldOfView_mm_.set (x);
  }

  void encodingSpaceType::
  fieldOfView_mm (::std::auto_ptr< fieldOfView_mm_type > x)
  {
    this->fieldOfView_mm_.set (x);
  }


  // matrixSize
  // 

  const matrixSize::x_type& matrixSize::
  x () const
  {
    return this->x_.get ();
  }

  matrixSize::x_type& matrixSize::
  x ()
  {
    return this->x_.get ();
  }

  void matrixSize::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  matrixSize::x_type matrixSize::
  x_default_value ()
  {
    return x_type (1);
  }

  const matrixSize::y_type& matrixSize::
  y () const
  {
    return this->y_.get ();
  }

  matrixSize::y_type& matrixSize::
  y ()
  {
    return this->y_.get ();
  }

  void matrixSize::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  matrixSize::y_type matrixSize::
  y_default_value ()
  {
    return y_type (1);
  }

  const matrixSize::z_type& matrixSize::
  z () const
  {
    return this->z_.get ();
  }

  matrixSize::z_type& matrixSize::
  z ()
  {
    return this->z_.get ();
  }

  void matrixSize::
  z (const z_type& x)
  {
    this->z_.set (x);
  }

  matrixSize::z_type matrixSize::
  z_default_value ()
  {
    return z_type (1);
  }


  // fieldOfView_mm
  // 

  const fieldOfView_mm::x_type& fieldOfView_mm::
  x () const
  {
    return this->x_.get ();
  }

  fieldOfView_mm::x_type& fieldOfView_mm::
  x ()
  {
    return this->x_.get ();
  }

  void fieldOfView_mm::
  x (const x_type& x)
  {
    this->x_.set (x);
  }

  const fieldOfView_mm::y_type& fieldOfView_mm::
  y () const
  {
    return this->y_.get ();
  }

  fieldOfView_mm::y_type& fieldOfView_mm::
  y ()
  {
    return this->y_.get ();
  }

  void fieldOfView_mm::
  y (const y_type& x)
  {
    this->y_.set (x);
  }

  const fieldOfView_mm::z_type& fieldOfView_mm::
  z () const
  {
    return this->z_.get ();
  }

  fieldOfView_mm::z_type& fieldOfView_mm::
  z ()
  {
    return this->z_.get ();
  }

  void fieldOfView_mm::
  z (const z_type& x)
  {
    this->z_.set (x);
  }


  // limitType
  // 

  const limitType::minimum_type& limitType::
  minimum () const
  {
    return this->minimum_.get ();
  }

  limitType::minimum_type& limitType::
  minimum ()
  {
    return this->minimum_.get ();
  }

  void limitType::
  minimum (const minimum_type& x)
  {
    this->minimum_.set (x);
  }

  limitType::minimum_type limitType::
  minimum_default_value ()
  {
    return minimum_type (0);
  }

  const limitType::maximum_type& limitType::
  maximum () const
  {
    return this->maximum_.get ();
  }

  limitType::maximum_type& limitType::
  maximum ()
  {
    return this->maximum_.get ();
  }

  void limitType::
  maximum (const maximum_type& x)
  {
    this->maximum_.set (x);
  }

  limitType::maximum_type limitType::
  maximum_default_value ()
  {
    return maximum_type (0);
  }

  const limitType::center_type& limitType::
  center () const
  {
    return this->center_.get ();
  }

  limitType::center_type& limitType::
  center ()
  {
    return this->center_.get ();
  }

  void limitType::
  center (const center_type& x)
  {
    this->center_.set (x);
  }

  limitType::center_type limitType::
  center_default_value ()
  {
    return center_type (0);
  }


  // encodingLimitsType
  // 

  const encodingLimitsType::kspace_encoding_step_0_optional& encodingLimitsType::
  kspace_encoding_step_0 () const
  {
    return this->kspace_encoding_step_0_;
  }

  encodingLimitsType::kspace_encoding_step_0_optional& encodingLimitsType::
  kspace_encoding_step_0 ()
  {
    return this->kspace_encoding_step_0_;
  }

  void encodingLimitsType::
  kspace_encoding_step_0 (const kspace_encoding_step_0_type& x)
  {
    this->kspace_encoding_step_0_.set (x);
  }

  void encodingLimitsType::
  kspace_encoding_step_0 (const kspace_encoding_step_0_optional& x)
  {
    this->kspace_encoding_step_0_ = x;
  }

  void encodingLimitsType::
  kspace_encoding_step_0 (::std::auto_ptr< kspace_encoding_step_0_type > x)
  {
    this->kspace_encoding_step_0_.set (x);
  }

  const encodingLimitsType::kspace_encoding_step_1_optional& encodingLimitsType::
  kspace_encoding_step_1 () const
  {
    return this->kspace_encoding_step_1_;
  }

  encodingLimitsType::kspace_encoding_step_1_optional& encodingLimitsType::
  kspace_encoding_step_1 ()
  {
    return this->kspace_encoding_step_1_;
  }

  void encodingLimitsType::
  kspace_encoding_step_1 (const kspace_encoding_step_1_type& x)
  {
    this->kspace_encoding_step_1_.set (x);
  }

  void encodingLimitsType::
  kspace_encoding_step_1 (const kspace_encoding_step_1_optional& x)
  {
    this->kspace_encoding_step_1_ = x;
  }

  void encodingLimitsType::
  kspace_encoding_step_1 (::std::auto_ptr< kspace_encoding_step_1_type > x)
  {
    this->kspace_encoding_step_1_.set (x);
  }

  const encodingLimitsType::kspace_encoding_step_2_optional& encodingLimitsType::
  kspace_encoding_step_2 () const
  {
    return this->kspace_encoding_step_2_;
  }

  encodingLimitsType::kspace_encoding_step_2_optional& encodingLimitsType::
  kspace_encoding_step_2 ()
  {
    return this->kspace_encoding_step_2_;
  }

  void encodingLimitsType::
  kspace_encoding_step_2 (const kspace_encoding_step_2_type& x)
  {
    this->kspace_encoding_step_2_.set (x);
  }

  void encodingLimitsType::
  kspace_encoding_step_2 (const kspace_encoding_step_2_optional& x)
  {
    this->kspace_encoding_step_2_ = x;
  }

  void encodingLimitsType::
  kspace_encoding_step_2 (::std::auto_ptr< kspace_encoding_step_2_type > x)
  {
    this->kspace_encoding_step_2_.set (x);
  }

  const encodingLimitsType::average_optional& encodingLimitsType::
  average () const
  {
    return this->average_;
  }

  encodingLimitsType::average_optional& encodingLimitsType::
  average ()
  {
    return this->average_;
  }

  void encodingLimitsType::
  average (const average_type& x)
  {
    this->average_.set (x);
  }

  void encodingLimitsType::
  average (const average_optional& x)
  {
    this->average_ = x;
  }

  void encodingLimitsType::
  average (::std::auto_ptr< average_type > x)
  {
    this->average_.set (x);
  }

  const encodingLimitsType::slice_optional& encodingLimitsType::
  slice () const
  {
    return this->slice_;
  }

  encodingLimitsType::slice_optional& encodingLimitsType::
  slice ()
  {
    return this->slice_;
  }

  void encodingLimitsType::
  slice (const slice_type& x)
  {
    this->slice_.set (x);
  }

  void encodingLimitsType::
  slice (const slice_optional& x)
  {
    this->slice_ = x;
  }

  void encodingLimitsType::
  slice (::std::auto_ptr< slice_type > x)
  {
    this->slice_.set (x);
  }

  const encodingLimitsType::contrast_optional& encodingLimitsType::
  contrast () const
  {
    return this->contrast_;
  }

  encodingLimitsType::contrast_optional& encodingLimitsType::
  contrast ()
  {
    return this->contrast_;
  }

  void encodingLimitsType::
  contrast (const contrast_type& x)
  {
    this->contrast_.set (x);
  }

  void encodingLimitsType::
  contrast (const contrast_optional& x)
  {
    this->contrast_ = x;
  }

  void encodingLimitsType::
  contrast (::std::auto_ptr< contrast_type > x)
  {
    this->contrast_.set (x);
  }

  const encodingLimitsType::phase_optional& encodingLimitsType::
  phase () const
  {
    return this->phase_;
  }

  encodingLimitsType::phase_optional& encodingLimitsType::
  phase ()
  {
    return this->phase_;
  }

  void encodingLimitsType::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void encodingLimitsType::
  phase (const phase_optional& x)
  {
    this->phase_ = x;
  }

  void encodingLimitsType::
  phase (::std::auto_ptr< phase_type > x)
  {
    this->phase_.set (x);
  }

  const encodingLimitsType::repetition_optional& encodingLimitsType::
  repetition () const
  {
    return this->repetition_;
  }

  encodingLimitsType::repetition_optional& encodingLimitsType::
  repetition ()
  {
    return this->repetition_;
  }

  void encodingLimitsType::
  repetition (const repetition_type& x)
  {
    this->repetition_.set (x);
  }

  void encodingLimitsType::
  repetition (const repetition_optional& x)
  {
    this->repetition_ = x;
  }

  void encodingLimitsType::
  repetition (::std::auto_ptr< repetition_type > x)
  {
    this->repetition_.set (x);
  }

  const encodingLimitsType::set_optional& encodingLimitsType::
  set () const
  {
    return this->set_;
  }

  encodingLimitsType::set_optional& encodingLimitsType::
  set ()
  {
    return this->set_;
  }

  void encodingLimitsType::
  set (const set_type& x)
  {
    this->set_.set (x);
  }

  void encodingLimitsType::
  set (const set_optional& x)
  {
    this->set_ = x;
  }

  void encodingLimitsType::
  set (::std::auto_ptr< set_type > x)
  {
    this->set_.set (x);
  }

  const encodingLimitsType::segment_optional& encodingLimitsType::
  segment () const
  {
    return this->segment_;
  }

  encodingLimitsType::segment_optional& encodingLimitsType::
  segment ()
  {
    return this->segment_;
  }

  void encodingLimitsType::
  segment (const segment_type& x)
  {
    this->segment_.set (x);
  }

  void encodingLimitsType::
  segment (const segment_optional& x)
  {
    this->segment_ = x;
  }

  void encodingLimitsType::
  segment (::std::auto_ptr< segment_type > x)
  {
    this->segment_.set (x);
  }


  // trajectoryType
  // 

  trajectoryType::
  trajectoryType (value v)
  : ::xml_schema::string (_xsd_trajectoryType_literals_[v])
  {
  }

  trajectoryType::
  trajectoryType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  trajectoryType::
  trajectoryType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  trajectoryType::
  trajectoryType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  trajectoryType::
  trajectoryType (const trajectoryType& v,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  trajectoryType& trajectoryType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_trajectoryType_literals_[v]);

    return *this;
  }


  // trajectoryDescriptionType
  // 

  const trajectoryDescriptionType::identifier_type& trajectoryDescriptionType::
  identifier () const
  {
    return this->identifier_.get ();
  }

  trajectoryDescriptionType::identifier_type& trajectoryDescriptionType::
  identifier ()
  {
    return this->identifier_.get ();
  }

  void trajectoryDescriptionType::
  identifier (const identifier_type& x)
  {
    this->identifier_.set (x);
  }

  void trajectoryDescriptionType::
  identifier (::std::auto_ptr< identifier_type > x)
  {
    this->identifier_.set (x);
  }

  const trajectoryDescriptionType::userParameterLong_sequence& trajectoryDescriptionType::
  userParameterLong () const
  {
    return this->userParameterLong_;
  }

  trajectoryDescriptionType::userParameterLong_sequence& trajectoryDescriptionType::
  userParameterLong ()
  {
    return this->userParameterLong_;
  }

  void trajectoryDescriptionType::
  userParameterLong (const userParameterLong_sequence& s)
  {
    this->userParameterLong_ = s;
  }

  const trajectoryDescriptionType::userParameterDouble_sequence& trajectoryDescriptionType::
  userParameterDouble () const
  {
    return this->userParameterDouble_;
  }

  trajectoryDescriptionType::userParameterDouble_sequence& trajectoryDescriptionType::
  userParameterDouble ()
  {
    return this->userParameterDouble_;
  }

  void trajectoryDescriptionType::
  userParameterDouble (const userParameterDouble_sequence& s)
  {
    this->userParameterDouble_ = s;
  }

  const trajectoryDescriptionType::comment_optional& trajectoryDescriptionType::
  comment () const
  {
    return this->comment_;
  }

  trajectoryDescriptionType::comment_optional& trajectoryDescriptionType::
  comment ()
  {
    return this->comment_;
  }

  void trajectoryDescriptionType::
  comment (const comment_type& x)
  {
    this->comment_.set (x);
  }

  void trajectoryDescriptionType::
  comment (const comment_optional& x)
  {
    this->comment_ = x;
  }

  void trajectoryDescriptionType::
  comment (::std::auto_ptr< comment_type > x)
  {
    this->comment_.set (x);
  }


  // sequenceParametersType
  // 

  const sequenceParametersType::TR_sequence& sequenceParametersType::
  TR () const
  {
    return this->TR_;
  }

  sequenceParametersType::TR_sequence& sequenceParametersType::
  TR ()
  {
    return this->TR_;
  }

  void sequenceParametersType::
  TR (const TR_sequence& s)
  {
    this->TR_ = s;
  }

  const sequenceParametersType::TE_sequence& sequenceParametersType::
  TE () const
  {
    return this->TE_;
  }

  sequenceParametersType::TE_sequence& sequenceParametersType::
  TE ()
  {
    return this->TE_;
  }

  void sequenceParametersType::
  TE (const TE_sequence& s)
  {
    this->TE_ = s;
  }

  const sequenceParametersType::TI_sequence& sequenceParametersType::
  TI () const
  {
    return this->TI_;
  }

  sequenceParametersType::TI_sequence& sequenceParametersType::
  TI ()
  {
    return this->TI_;
  }

  void sequenceParametersType::
  TI (const TI_sequence& s)
  {
    this->TI_ = s;
  }


  // userParameterLongType
  // 

  const userParameterLongType::name_type& userParameterLongType::
  name () const
  {
    return this->name_.get ();
  }

  userParameterLongType::name_type& userParameterLongType::
  name ()
  {
    return this->name_.get ();
  }

  void userParameterLongType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void userParameterLongType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const userParameterLongType::value_type& userParameterLongType::
  value () const
  {
    return this->value_.get ();
  }

  userParameterLongType::value_type& userParameterLongType::
  value ()
  {
    return this->value_.get ();
  }

  void userParameterLongType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // userParameterDoubleType
  // 

  const userParameterDoubleType::name_type& userParameterDoubleType::
  name () const
  {
    return this->name_.get ();
  }

  userParameterDoubleType::name_type& userParameterDoubleType::
  name ()
  {
    return this->name_.get ();
  }

  void userParameterDoubleType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void userParameterDoubleType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const userParameterDoubleType::value_type& userParameterDoubleType::
  value () const
  {
    return this->value_.get ();
  }

  userParameterDoubleType::value_type& userParameterDoubleType::
  value ()
  {
    return this->value_.get ();
  }

  void userParameterDoubleType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }


  // userParameterStringType
  // 

  const userParameterStringType::name_type& userParameterStringType::
  name () const
  {
    return this->name_.get ();
  }

  userParameterStringType::name_type& userParameterStringType::
  name ()
  {
    return this->name_.get ();
  }

  void userParameterStringType::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void userParameterStringType::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const userParameterStringType::value_type& userParameterStringType::
  value () const
  {
    return this->value_.get ();
  }

  userParameterStringType::value_type& userParameterStringType::
  value ()
  {
    return this->value_.get ();
  }

  void userParameterStringType::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void userParameterStringType::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // userParameterBase64Type
  // 

  const userParameterBase64Type::name_type& userParameterBase64Type::
  name () const
  {
    return this->name_.get ();
  }

  userParameterBase64Type::name_type& userParameterBase64Type::
  name ()
  {
    return this->name_.get ();
  }

  void userParameterBase64Type::
  name (const name_type& x)
  {
    this->name_.set (x);
  }

  void userParameterBase64Type::
  name (::std::auto_ptr< name_type > x)
  {
    this->name_.set (x);
  }

  const userParameterBase64Type::value_type& userParameterBase64Type::
  value () const
  {
    return this->value_.get ();
  }

  userParameterBase64Type::value_type& userParameterBase64Type::
  value ()
  {
    return this->value_.get ();
  }

  void userParameterBase64Type::
  value (const value_type& x)
  {
    this->value_.set (x);
  }

  void userParameterBase64Type::
  value (::std::auto_ptr< value_type > x)
  {
    this->value_.set (x);
  }


  // dicomParametersType
  // 

  const dicomParametersType::studyInstanceUID_type& dicomParametersType::
  studyInstanceUID () const
  {
    return this->studyInstanceUID_.get ();
  }

  dicomParametersType::studyInstanceUID_type& dicomParametersType::
  studyInstanceUID ()
  {
    return this->studyInstanceUID_.get ();
  }

  void dicomParametersType::
  studyInstanceUID (const studyInstanceUID_type& x)
  {
    this->studyInstanceUID_.set (x);
  }

  void dicomParametersType::
  studyInstanceUID (::std::auto_ptr< studyInstanceUID_type > x)
  {
    this->studyInstanceUID_.set (x);
  }

  const dicomParametersType::seriesInstanceUIDRoot_optional& dicomParametersType::
  seriesInstanceUIDRoot () const
  {
    return this->seriesInstanceUIDRoot_;
  }

  dicomParametersType::seriesInstanceUIDRoot_optional& dicomParametersType::
  seriesInstanceUIDRoot ()
  {
    return this->seriesInstanceUIDRoot_;
  }

  void dicomParametersType::
  seriesInstanceUIDRoot (const seriesInstanceUIDRoot_type& x)
  {
    this->seriesInstanceUIDRoot_.set (x);
  }

  void dicomParametersType::
  seriesInstanceUIDRoot (const seriesInstanceUIDRoot_optional& x)
  {
    this->seriesInstanceUIDRoot_ = x;
  }

  void dicomParametersType::
  seriesInstanceUIDRoot (::std::auto_ptr< seriesInstanceUIDRoot_type > x)
  {
    this->seriesInstanceUIDRoot_.set (x);
  }

  const dicomParametersType::frameOfReferenceUID_optional& dicomParametersType::
  frameOfReferenceUID () const
  {
    return this->frameOfReferenceUID_;
  }

  dicomParametersType::frameOfReferenceUID_optional& dicomParametersType::
  frameOfReferenceUID ()
  {
    return this->frameOfReferenceUID_;
  }

  void dicomParametersType::
  frameOfReferenceUID (const frameOfReferenceUID_type& x)
  {
    this->frameOfReferenceUID_.set (x);
  }

  void dicomParametersType::
  frameOfReferenceUID (const frameOfReferenceUID_optional& x)
  {
    this->frameOfReferenceUID_ = x;
  }

  void dicomParametersType::
  frameOfReferenceUID (::std::auto_ptr< frameOfReferenceUID_type > x)
  {
    this->frameOfReferenceUID_.set (x);
  }

  const dicomParametersType::referencedImageSequence_optional& dicomParametersType::
  referencedImageSequence () const
  {
    return this->referencedImageSequence_;
  }

  dicomParametersType::referencedImageSequence_optional& dicomParametersType::
  referencedImageSequence ()
  {
    return this->referencedImageSequence_;
  }

  void dicomParametersType::
  referencedImageSequence (const referencedImageSequence_type& x)
  {
    this->referencedImageSequence_.set (x);
  }

  void dicomParametersType::
  referencedImageSequence (const referencedImageSequence_optional& x)
  {
    this->referencedImageSequence_ = x;
  }

  void dicomParametersType::
  referencedImageSequence (::std::auto_ptr< referencedImageSequence_type > x)
  {
    this->referencedImageSequence_.set (x);
  }

  const dicomParametersType::MRImageModule_optional& dicomParametersType::
  MRImageModule () const
  {
    return this->MRImageModule_;
  }

  dicomParametersType::MRImageModule_optional& dicomParametersType::
  MRImageModule ()
  {
    return this->MRImageModule_;
  }

  void dicomParametersType::
  MRImageModule (const MRImageModule_type& x)
  {
    this->MRImageModule_.set (x);
  }

  void dicomParametersType::
  MRImageModule (const MRImageModule_optional& x)
  {
    this->MRImageModule_ = x;
  }

  void dicomParametersType::
  MRImageModule (::std::auto_ptr< MRImageModule_type > x)
  {
    this->MRImageModule_.set (x);
  }


  // referencedImageSequence
  // 

  const referencedImageSequence::referencedSOPInstanceUID_sequence& referencedImageSequence::
  referencedSOPInstanceUID () const
  {
    return this->referencedSOPInstanceUID_;
  }

  referencedImageSequence::referencedSOPInstanceUID_sequence& referencedImageSequence::
  referencedSOPInstanceUID ()
  {
    return this->referencedSOPInstanceUID_;
  }

  void referencedImageSequence::
  referencedSOPInstanceUID (const referencedSOPInstanceUID_sequence& s)
  {
    this->referencedSOPInstanceUID_ = s;
  }


  // MRImageModule
  // 

  const MRImageModule::imageType_optional& MRImageModule::
  imageType () const
  {
    return this->imageType_;
  }

  MRImageModule::imageType_optional& MRImageModule::
  imageType ()
  {
    return this->imageType_;
  }

  void MRImageModule::
  imageType (const imageType_type& x)
  {
    this->imageType_.set (x);
  }

  void MRImageModule::
  imageType (const imageType_optional& x)
  {
    this->imageType_ = x;
  }

  void MRImageModule::
  imageType (::std::auto_ptr< imageType_type > x)
  {
    this->imageType_.set (x);
  }

  const MRImageModule::scanningSequence_optional& MRImageModule::
  scanningSequence () const
  {
    return this->scanningSequence_;
  }

  MRImageModule::scanningSequence_optional& MRImageModule::
  scanningSequence ()
  {
    return this->scanningSequence_;
  }

  void MRImageModule::
  scanningSequence (const scanningSequence_type& x)
  {
    this->scanningSequence_.set (x);
  }

  void MRImageModule::
  scanningSequence (const scanningSequence_optional& x)
  {
    this->scanningSequence_ = x;
  }

  void MRImageModule::
  scanningSequence (::std::auto_ptr< scanningSequence_type > x)
  {
    this->scanningSequence_.set (x);
  }

  const MRImageModule::sequenceVariant_optional& MRImageModule::
  sequenceVariant () const
  {
    return this->sequenceVariant_;
  }

  MRImageModule::sequenceVariant_optional& MRImageModule::
  sequenceVariant ()
  {
    return this->sequenceVariant_;
  }

  void MRImageModule::
  sequenceVariant (const sequenceVariant_type& x)
  {
    this->sequenceVariant_.set (x);
  }

  void MRImageModule::
  sequenceVariant (const sequenceVariant_optional& x)
  {
    this->sequenceVariant_ = x;
  }

  void MRImageModule::
  sequenceVariant (::std::auto_ptr< sequenceVariant_type > x)
  {
    this->sequenceVariant_.set (x);
  }

  const MRImageModule::scanOptions_optional& MRImageModule::
  scanOptions () const
  {
    return this->scanOptions_;
  }

  MRImageModule::scanOptions_optional& MRImageModule::
  scanOptions ()
  {
    return this->scanOptions_;
  }

  void MRImageModule::
  scanOptions (const scanOptions_type& x)
  {
    this->scanOptions_.set (x);
  }

  void MRImageModule::
  scanOptions (const scanOptions_optional& x)
  {
    this->scanOptions_ = x;
  }

  void MRImageModule::
  scanOptions (::std::auto_ptr< scanOptions_type > x)
  {
    this->scanOptions_.set (x);
  }

  const MRImageModule::mrAcquisitionType_optional& MRImageModule::
  mrAcquisitionType () const
  {
    return this->mrAcquisitionType_;
  }

  MRImageModule::mrAcquisitionType_optional& MRImageModule::
  mrAcquisitionType ()
  {
    return this->mrAcquisitionType_;
  }

  void MRImageModule::
  mrAcquisitionType (const mrAcquisitionType_type& x)
  {
    this->mrAcquisitionType_.set (x);
  }

  void MRImageModule::
  mrAcquisitionType (const mrAcquisitionType_optional& x)
  {
    this->mrAcquisitionType_ = x;
  }

  void MRImageModule::
  mrAcquisitionType (::std::auto_ptr< mrAcquisitionType_type > x)
  {
    this->mrAcquisitionType_.set (x);
  }

  const MRImageModule::echoTrainLength_optional& MRImageModule::
  echoTrainLength () const
  {
    return this->echoTrainLength_;
  }

  MRImageModule::echoTrainLength_optional& MRImageModule::
  echoTrainLength ()
  {
    return this->echoTrainLength_;
  }

  void MRImageModule::
  echoTrainLength (const echoTrainLength_type& x)
  {
    this->echoTrainLength_.set (x);
  }

  void MRImageModule::
  echoTrainLength (const echoTrainLength_optional& x)
  {
    this->echoTrainLength_ = x;
  }

  const MRImageModule::triggerTime_optional& MRImageModule::
  triggerTime () const
  {
    return this->triggerTime_;
  }

  MRImageModule::triggerTime_optional& MRImageModule::
  triggerTime ()
  {
    return this->triggerTime_;
  }

  void MRImageModule::
  triggerTime (const triggerTime_type& x)
  {
    this->triggerTime_.set (x);
  }

  void MRImageModule::
  triggerTime (const triggerTime_optional& x)
  {
    this->triggerTime_ = x;
  }

  const MRImageModule::flipAngle_deg_optional& MRImageModule::
  flipAngle_deg () const
  {
    return this->flipAngle_deg_;
  }

  MRImageModule::flipAngle_deg_optional& MRImageModule::
  flipAngle_deg ()
  {
    return this->flipAngle_deg_;
  }

  void MRImageModule::
  flipAngle_deg (const flipAngle_deg_type& x)
  {
    this->flipAngle_deg_.set (x);
  }

  void MRImageModule::
  flipAngle_deg (const flipAngle_deg_optional& x)
  {
    this->flipAngle_deg_ = x;
  }

  const MRImageModule::freqEncodingDirection_optional& MRImageModule::
  freqEncodingDirection () const
  {
    return this->freqEncodingDirection_;
  }

  MRImageModule::freqEncodingDirection_optional& MRImageModule::
  freqEncodingDirection ()
  {
    return this->freqEncodingDirection_;
  }

  void MRImageModule::
  freqEncodingDirection (const freqEncodingDirection_type& x)
  {
    this->freqEncodingDirection_.set (x);
  }

  void MRImageModule::
  freqEncodingDirection (const freqEncodingDirection_optional& x)
  {
    this->freqEncodingDirection_ = x;
  }

  void MRImageModule::
  freqEncodingDirection (::std::auto_ptr< freqEncodingDirection_type > x)
  {
    this->freqEncodingDirection_.set (x);
  }


  // userParameters
  // 

  const userParameters::userParameterLong_sequence& userParameters::
  userParameterLong () const
  {
    return this->userParameterLong_;
  }

  userParameters::userParameterLong_sequence& userParameters::
  userParameterLong ()
  {
    return this->userParameterLong_;
  }

  void userParameters::
  userParameterLong (const userParameterLong_sequence& s)
  {
    this->userParameterLong_ = s;
  }

  const userParameters::userParameterDouble_sequence& userParameters::
  userParameterDouble () const
  {
    return this->userParameterDouble_;
  }

  userParameters::userParameterDouble_sequence& userParameters::
  userParameterDouble ()
  {
    return this->userParameterDouble_;
  }

  void userParameters::
  userParameterDouble (const userParameterDouble_sequence& s)
  {
    this->userParameterDouble_ = s;
  }

  const userParameters::userParameterString_sequence& userParameters::
  userParameterString () const
  {
    return this->userParameterString_;
  }

  userParameters::userParameterString_sequence& userParameters::
  userParameterString ()
  {
    return this->userParameterString_;
  }

  void userParameters::
  userParameterString (const userParameterString_sequence& s)
  {
    this->userParameterString_ = s;
  }

  const userParameters::userParameterBase64_sequence& userParameters::
  userParameterBase64 () const
  {
    return this->userParameterBase64_;
  }

  userParameters::userParameterBase64_sequence& userParameters::
  userParameterBase64 ()
  {
    return this->userParameterBase64_;
  }

  void userParameters::
  userParameterBase64 (const userParameterBase64_sequence& s)
  {
    this->userParameterBase64_ = s;
  }


  // accelerationFactorType
  // 

  const accelerationFactorType::kspace_encoding_step_1_type& accelerationFactorType::
  kspace_encoding_step_1 () const
  {
    return this->kspace_encoding_step_1_.get ();
  }

  accelerationFactorType::kspace_encoding_step_1_type& accelerationFactorType::
  kspace_encoding_step_1 ()
  {
    return this->kspace_encoding_step_1_.get ();
  }

  void accelerationFactorType::
  kspace_encoding_step_1 (const kspace_encoding_step_1_type& x)
  {
    this->kspace_encoding_step_1_.set (x);
  }

  const accelerationFactorType::kspace_encoding_step_2_type& accelerationFactorType::
  kspace_encoding_step_2 () const
  {
    return this->kspace_encoding_step_2_.get ();
  }

  accelerationFactorType::kspace_encoding_step_2_type& accelerationFactorType::
  kspace_encoding_step_2 ()
  {
    return this->kspace_encoding_step_2_.get ();
  }

  void accelerationFactorType::
  kspace_encoding_step_2 (const kspace_encoding_step_2_type& x)
  {
    this->kspace_encoding_step_2_.set (x);
  }


  // calibrationModeType
  // 

  calibrationModeType::
  calibrationModeType (value v)
  : ::xml_schema::string (_xsd_calibrationModeType_literals_[v])
  {
  }

  calibrationModeType::
  calibrationModeType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  calibrationModeType::
  calibrationModeType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  calibrationModeType::
  calibrationModeType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  calibrationModeType::
  calibrationModeType (const calibrationModeType& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  calibrationModeType& calibrationModeType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_calibrationModeType_literals_[v]);

    return *this;
  }


  // interleavingDimensionType
  // 

  interleavingDimensionType::
  interleavingDimensionType (value v)
  : ::xml_schema::string (_xsd_interleavingDimensionType_literals_[v])
  {
  }

  interleavingDimensionType::
  interleavingDimensionType (const char* v)
  : ::xml_schema::string (v)
  {
  }

  interleavingDimensionType::
  interleavingDimensionType (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  interleavingDimensionType::
  interleavingDimensionType (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  interleavingDimensionType::
  interleavingDimensionType (const interleavingDimensionType& v,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  interleavingDimensionType& interleavingDimensionType::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_interleavingDimensionType_literals_[v]);

    return *this;
  }


  // parallelImagingType
  // 

  const parallelImagingType::accelerationFactor_type& parallelImagingType::
  accelerationFactor () const
  {
    return this->accelerationFactor_.get ();
  }

  parallelImagingType::accelerationFactor_type& parallelImagingType::
  accelerationFactor ()
  {
    return this->accelerationFactor_.get ();
  }

  void parallelImagingType::
  accelerationFactor (const accelerationFactor_type& x)
  {
    this->accelerationFactor_.set (x);
  }

  void parallelImagingType::
  accelerationFactor (::std::auto_ptr< accelerationFactor_type > x)
  {
    this->accelerationFactor_.set (x);
  }

  const parallelImagingType::calibrationMode_optional& parallelImagingType::
  calibrationMode () const
  {
    return this->calibrationMode_;
  }

  parallelImagingType::calibrationMode_optional& parallelImagingType::
  calibrationMode ()
  {
    return this->calibrationMode_;
  }

  void parallelImagingType::
  calibrationMode (const calibrationMode_type& x)
  {
    this->calibrationMode_.set (x);
  }

  void parallelImagingType::
  calibrationMode (const calibrationMode_optional& x)
  {
    this->calibrationMode_ = x;
  }

  void parallelImagingType::
  calibrationMode (::std::auto_ptr< calibrationMode_type > x)
  {
    this->calibrationMode_.set (x);
  }

  const parallelImagingType::interleavingDimension_optional& parallelImagingType::
  interleavingDimension () const
  {
    return this->interleavingDimension_;
  }

  parallelImagingType::interleavingDimension_optional& parallelImagingType::
  interleavingDimension ()
  {
    return this->interleavingDimension_;
  }

  void parallelImagingType::
  interleavingDimension (const interleavingDimension_type& x)
  {
    this->interleavingDimension_.set (x);
  }

  void parallelImagingType::
  interleavingDimension (const interleavingDimension_optional& x)
  {
    this->interleavingDimension_ = x;
  }

  void parallelImagingType::
  interleavingDimension (::std::auto_ptr< interleavingDimension_type > x)
  {
    this->interleavingDimension_.set (x);
  }


  // patientGender
  // 


  // patientPosition
  // 

  patientPosition::
  patientPosition (value v)
  : ::xml_schema::string (_xsd_patientPosition_literals_[v])
  {
  }

  patientPosition::
  patientPosition (const char* v)
  : ::xml_schema::string (v)
  {
  }

  patientPosition::
  patientPosition (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  patientPosition::
  patientPosition (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  patientPosition::
  patientPosition (const patientPosition& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  patientPosition& patientPosition::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_patientPosition_literals_[v]);

    return *this;
  }


  // freqEncodingDirection
  // 

  freqEncodingDirection::
  freqEncodingDirection (value v)
  : ::xml_schema::string (_xsd_freqEncodingDirection_literals_[v])
  {
  }

  freqEncodingDirection::
  freqEncodingDirection (const char* v)
  : ::xml_schema::string (v)
  {
  }

  freqEncodingDirection::
  freqEncodingDirection (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  freqEncodingDirection::
  freqEncodingDirection (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  freqEncodingDirection::
  freqEncodingDirection (const freqEncodingDirection& v,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  freqEncodingDirection& freqEncodingDirection::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_freqEncodingDirection_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace ISMRMRD
{
  // ismrmrdHeader
  //

  ismrmrdHeader::
  ismrmrdHeader (const experimentalConditions_type& experimentalConditions)
  : ::xml_schema::type (),
    subjectInformation_ (::xml_schema::flags (), this),
    studyInformation_ (::xml_schema::flags (), this),
    measurementInformation_ (::xml_schema::flags (), this),
    acquisitionSystemInformation_ (::xml_schema::flags (), this),
    experimentalConditions_ (experimentalConditions, ::xml_schema::flags (), this),
    encoding_ (::xml_schema::flags (), this),
    parallelImaging_ (::xml_schema::flags (), this),
    sequenceParameters_ (::xml_schema::flags (), this),
    dicomParameters_ (::xml_schema::flags (), this),
    userParameters_ (::xml_schema::flags (), this)
  {
  }

  ismrmrdHeader::
  ismrmrdHeader (::std::auto_ptr< experimentalConditions_type >& experimentalConditions)
  : ::xml_schema::type (),
    subjectInformation_ (::xml_schema::flags (), this),
    studyInformation_ (::xml_schema::flags (), this),
    measurementInformation_ (::xml_schema::flags (), this),
    acquisitionSystemInformation_ (::xml_schema::flags (), this),
    experimentalConditions_ (experimentalConditions, ::xml_schema::flags (), this),
    encoding_ (::xml_schema::flags (), this),
    parallelImaging_ (::xml_schema::flags (), this),
    sequenceParameters_ (::xml_schema::flags (), this),
    dicomParameters_ (::xml_schema::flags (), this),
    userParameters_ (::xml_schema::flags (), this)
  {
  }

  ismrmrdHeader::
  ismrmrdHeader (const ismrmrdHeader& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    subjectInformation_ (x.subjectInformation_, f, this),
    studyInformation_ (x.studyInformation_, f, this),
    measurementInformation_ (x.measurementInformation_, f, this),
    acquisitionSystemInformation_ (x.acquisitionSystemInformation_, f, this),
    experimentalConditions_ (x.experimentalConditions_, f, this),
    encoding_ (x.encoding_, f, this),
    parallelImaging_ (x.parallelImaging_, f, this),
    sequenceParameters_ (x.sequenceParameters_, f, this),
    dicomParameters_ (x.dicomParameters_, f, this),
    userParameters_ (x.userParameters_, f, this)
  {
  }

  ismrmrdHeader::
  ismrmrdHeader (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    subjectInformation_ (f, this),
    studyInformation_ (f, this),
    measurementInformation_ (f, this),
    acquisitionSystemInformation_ (f, this),
    experimentalConditions_ (f, this),
    encoding_ (f, this),
    parallelImaging_ (f, this),
    sequenceParameters_ (f, this),
    dicomParameters_ (f, this),
    userParameters_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ismrmrdHeader::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subjectInformation
      //
      if (n.name () == "subjectInformation" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< subjectInformation_type > r (
          subjectInformation_traits::create (i, f, this));

        if (!this->subjectInformation_)
        {
          this->subjectInformation_.set (r);
          continue;
        }
      }

      // studyInformation
      //
      if (n.name () == "studyInformation" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< studyInformation_type > r (
          studyInformation_traits::create (i, f, this));

        if (!this->studyInformation_)
        {
          this->studyInformation_.set (r);
          continue;
        }
      }

      // measurementInformation
      //
      if (n.name () == "measurementInformation" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< measurementInformation_type > r (
          measurementInformation_traits::create (i, f, this));

        if (!this->measurementInformation_)
        {
          this->measurementInformation_.set (r);
          continue;
        }
      }

      // acquisitionSystemInformation
      //
      if (n.name () == "acquisitionSystemInformation" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< acquisitionSystemInformation_type > r (
          acquisitionSystemInformation_traits::create (i, f, this));

        if (!this->acquisitionSystemInformation_)
        {
          this->acquisitionSystemInformation_.set (r);
          continue;
        }
      }

      // experimentalConditions
      //
      if (n.name () == "experimentalConditions" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< experimentalConditions_type > r (
          experimentalConditions_traits::create (i, f, this));

        if (!experimentalConditions_.present ())
        {
          this->experimentalConditions_.set (r);
          continue;
        }
      }

      // encoding
      //
      if (n.name () == "encoding" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< encoding_type > r (
          encoding_traits::create (i, f, this));

        this->encoding_.push_back (r);
        continue;
      }

      // parallelImaging
      //
      if (n.name () == "parallelImaging" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< parallelImaging_type > r (
          parallelImaging_traits::create (i, f, this));

        if (!this->parallelImaging_)
        {
          this->parallelImaging_.set (r);
          continue;
        }
      }

      // sequenceParameters
      //
      if (n.name () == "sequenceParameters" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< sequenceParameters_type > r (
          sequenceParameters_traits::create (i, f, this));

        if (!this->sequenceParameters_)
        {
          this->sequenceParameters_.set (r);
          continue;
        }
      }

      // dicomParameters
      //
      if (n.name () == "dicomParameters" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< dicomParameters_type > r (
          dicomParameters_traits::create (i, f, this));

        if (!this->dicomParameters_)
        {
          this->dicomParameters_.set (r);
          continue;
        }
      }

      // userParameters
      //
      if (n.name () == "userParameters" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameters_type > r (
          userParameters_traits::create (i, f, this));

        if (!this->userParameters_)
        {
          this->userParameters_.set (r);
          continue;
        }
      }

      break;
    }

    if (!experimentalConditions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "experimentalConditions",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  ismrmrdHeader* ismrmrdHeader::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ismrmrdHeader (*this, f, c);
  }

  ismrmrdHeader::
  ~ismrmrdHeader ()
  {
  }

  // subjectInformationType
  //

  subjectInformationType::
  subjectInformationType ()
  : ::xml_schema::type (),
    patientName_ (::xml_schema::flags (), this),
    patientWeight_kg_ (::xml_schema::flags (), this),
    patientID_ (::xml_schema::flags (), this),
    patientBirthdate_ (::xml_schema::flags (), this),
    patientGender_ (::xml_schema::flags (), this)
  {
  }

  subjectInformationType::
  subjectInformationType (const subjectInformationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    patientName_ (x.patientName_, f, this),
    patientWeight_kg_ (x.patientWeight_kg_, f, this),
    patientID_ (x.patientID_, f, this),
    patientBirthdate_ (x.patientBirthdate_, f, this),
    patientGender_ (x.patientGender_, f, this)
  {
  }

  subjectInformationType::
  subjectInformationType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    patientName_ (f, this),
    patientWeight_kg_ (f, this),
    patientID_ (f, this),
    patientBirthdate_ (f, this),
    patientGender_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void subjectInformationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // patientName
      //
      if (n.name () == "patientName" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< patientName_type > r (
          patientName_traits::create (i, f, this));

        if (!this->patientName_)
        {
          this->patientName_.set (r);
          continue;
        }
      }

      // patientWeight_kg
      //
      if (n.name () == "patientWeight_kg" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->patientWeight_kg_)
        {
          this->patientWeight_kg_.set (patientWeight_kg_traits::create (i, f, this));
          continue;
        }
      }

      // patientID
      //
      if (n.name () == "patientID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< patientID_type > r (
          patientID_traits::create (i, f, this));

        if (!this->patientID_)
        {
          this->patientID_.set (r);
          continue;
        }
      }

      // patientBirthdate
      //
      if (n.name () == "patientBirthdate" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< patientBirthdate_type > r (
          patientBirthdate_traits::create (i, f, this));

        if (!this->patientBirthdate_)
        {
          this->patientBirthdate_.set (r);
          continue;
        }
      }

      // patientGender
      //
      if (n.name () == "patientGender" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< patientGender_type > r (
          patientGender_traits::create (i, f, this));

        if (!this->patientGender_)
        {
          this->patientGender_.set (r);
          continue;
        }
      }

      break;
    }
  }

  subjectInformationType* subjectInformationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class subjectInformationType (*this, f, c);
  }

  subjectInformationType::
  ~subjectInformationType ()
  {
  }

  // studyInformationType
  //

  studyInformationType::
  studyInformationType ()
  : ::xml_schema::type (),
    studyDate_ (::xml_schema::flags (), this),
    studyTime_ (::xml_schema::flags (), this),
    studyID_ (::xml_schema::flags (), this),
    accessionNumber_ (::xml_schema::flags (), this),
    referringPhysicianName_ (::xml_schema::flags (), this),
    studyDescription_ (::xml_schema::flags (), this)
  {
  }

  studyInformationType::
  studyInformationType (const studyInformationType& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    studyDate_ (x.studyDate_, f, this),
    studyTime_ (x.studyTime_, f, this),
    studyID_ (x.studyID_, f, this),
    accessionNumber_ (x.accessionNumber_, f, this),
    referringPhysicianName_ (x.referringPhysicianName_, f, this),
    studyDescription_ (x.studyDescription_, f, this)
  {
  }

  studyInformationType::
  studyInformationType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    studyDate_ (f, this),
    studyTime_ (f, this),
    studyID_ (f, this),
    accessionNumber_ (f, this),
    referringPhysicianName_ (f, this),
    studyDescription_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void studyInformationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // studyDate
      //
      if (n.name () == "studyDate" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< studyDate_type > r (
          studyDate_traits::create (i, f, this));

        if (!this->studyDate_)
        {
          this->studyDate_.set (r);
          continue;
        }
      }

      // studyTime
      //
      if (n.name () == "studyTime" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< studyTime_type > r (
          studyTime_traits::create (i, f, this));

        if (!this->studyTime_)
        {
          this->studyTime_.set (r);
          continue;
        }
      }

      // studyID
      //
      if (n.name () == "studyID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< studyID_type > r (
          studyID_traits::create (i, f, this));

        if (!this->studyID_)
        {
          this->studyID_.set (r);
          continue;
        }
      }

      // accessionNumber
      //
      if (n.name () == "accessionNumber" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->accessionNumber_)
        {
          this->accessionNumber_.set (accessionNumber_traits::create (i, f, this));
          continue;
        }
      }

      // referringPhysicianName
      //
      if (n.name () == "referringPhysicianName" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< referringPhysicianName_type > r (
          referringPhysicianName_traits::create (i, f, this));

        if (!this->referringPhysicianName_)
        {
          this->referringPhysicianName_.set (r);
          continue;
        }
      }

      // studyDescription
      //
      if (n.name () == "studyDescription" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< studyDescription_type > r (
          studyDescription_traits::create (i, f, this));

        if (!this->studyDescription_)
        {
          this->studyDescription_.set (r);
          continue;
        }
      }

      break;
    }
  }

  studyInformationType* studyInformationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class studyInformationType (*this, f, c);
  }

  studyInformationType::
  ~studyInformationType ()
  {
  }

  // measurementInformationType
  //

  measurementInformationType::
  measurementInformationType (const patientPosition_type& patientPosition)
  : ::xml_schema::type (),
    measurementID_ (::xml_schema::flags (), this),
    seriesDate_ (::xml_schema::flags (), this),
    seriesTime_ (::xml_schema::flags (), this),
    patientPosition_ (patientPosition, ::xml_schema::flags (), this),
    initialSeriesNumber_ (::xml_schema::flags (), this),
    protocolName_ (::xml_schema::flags (), this),
    seriesDescription_ (::xml_schema::flags (), this),
    measurementDependency_ (::xml_schema::flags (), this)
  {
  }

  measurementInformationType::
  measurementInformationType (const measurementInformationType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    measurementID_ (x.measurementID_, f, this),
    seriesDate_ (x.seriesDate_, f, this),
    seriesTime_ (x.seriesTime_, f, this),
    patientPosition_ (x.patientPosition_, f, this),
    initialSeriesNumber_ (x.initialSeriesNumber_, f, this),
    protocolName_ (x.protocolName_, f, this),
    seriesDescription_ (x.seriesDescription_, f, this),
    measurementDependency_ (x.measurementDependency_, f, this)
  {
  }

  measurementInformationType::
  measurementInformationType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    measurementID_ (f, this),
    seriesDate_ (f, this),
    seriesTime_ (f, this),
    patientPosition_ (f, this),
    initialSeriesNumber_ (f, this),
    protocolName_ (f, this),
    seriesDescription_ (f, this),
    measurementDependency_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void measurementInformationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // measurementID
      //
      if (n.name () == "measurementID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< measurementID_type > r (
          measurementID_traits::create (i, f, this));

        if (!this->measurementID_)
        {
          this->measurementID_.set (r);
          continue;
        }
      }

      // seriesDate
      //
      if (n.name () == "seriesDate" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< seriesDate_type > r (
          seriesDate_traits::create (i, f, this));

        if (!this->seriesDate_)
        {
          this->seriesDate_.set (r);
          continue;
        }
      }

      // seriesTime
      //
      if (n.name () == "seriesTime" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< seriesTime_type > r (
          seriesTime_traits::create (i, f, this));

        if (!this->seriesTime_)
        {
          this->seriesTime_.set (r);
          continue;
        }
      }

      // patientPosition
      //
      if (n.name () == "patientPosition" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< patientPosition_type > r (
          patientPosition_traits::create (i, f, this));

        if (!patientPosition_.present ())
        {
          this->patientPosition_.set (r);
          continue;
        }
      }

      // initialSeriesNumber
      //
      if (n.name () == "initialSeriesNumber" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->initialSeriesNumber_)
        {
          this->initialSeriesNumber_.set (initialSeriesNumber_traits::create (i, f, this));
          continue;
        }
      }

      // protocolName
      //
      if (n.name () == "protocolName" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< protocolName_type > r (
          protocolName_traits::create (i, f, this));

        if (!this->protocolName_)
        {
          this->protocolName_.set (r);
          continue;
        }
      }

      // seriesDescription
      //
      if (n.name () == "seriesDescription" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< seriesDescription_type > r (
          seriesDescription_traits::create (i, f, this));

        if (!this->seriesDescription_)
        {
          this->seriesDescription_.set (r);
          continue;
        }
      }

      // measurementDependency
      //
      if (n.name () == "measurementDependency" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< measurementDependency_type > r (
          measurementDependency_traits::create (i, f, this));

        this->measurementDependency_.push_back (r);
        continue;
      }

      break;
    }

    if (!patientPosition_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "patientPosition",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  measurementInformationType* measurementInformationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measurementInformationType (*this, f, c);
  }

  measurementInformationType::
  ~measurementInformationType ()
  {
  }

  // measurementDependencyType
  //

  measurementDependencyType::
  measurementDependencyType (const dependencyType_type& dependencyType,
                             const measurementID_type& measurementID)
  : ::xml_schema::type (),
    dependencyType_ (dependencyType, ::xml_schema::flags (), this),
    measurementID_ (measurementID, ::xml_schema::flags (), this)
  {
  }

  measurementDependencyType::
  measurementDependencyType (const measurementDependencyType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    dependencyType_ (x.dependencyType_, f, this),
    measurementID_ (x.measurementID_, f, this)
  {
  }

  measurementDependencyType::
  measurementDependencyType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    dependencyType_ (f, this),
    measurementID_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void measurementDependencyType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // dependencyType
      //
      if (n.name () == "dependencyType" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< dependencyType_type > r (
          dependencyType_traits::create (i, f, this));

        if (!dependencyType_.present ())
        {
          this->dependencyType_.set (r);
          continue;
        }
      }

      // measurementID
      //
      if (n.name () == "measurementID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< measurementID_type > r (
          measurementID_traits::create (i, f, this));

        if (!measurementID_.present ())
        {
          this->measurementID_.set (r);
          continue;
        }
      }

      break;
    }

    if (!dependencyType_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "dependencyType",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!measurementID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "measurementID",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  measurementDependencyType* measurementDependencyType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class measurementDependencyType (*this, f, c);
  }

  measurementDependencyType::
  ~measurementDependencyType ()
  {
  }

  // acquisitionSystemInformationType
  //

  acquisitionSystemInformationType::
  acquisitionSystemInformationType ()
  : ::xml_schema::type (),
    systemVendor_ (::xml_schema::flags (), this),
    systemModel_ (::xml_schema::flags (), this),
    systemFieldStrength_T_ (::xml_schema::flags (), this),
    relativeReceiverNoiseBandwidth_ (::xml_schema::flags (), this),
    receiverChannels_ (::xml_schema::flags (), this),
    institutionName_ (::xml_schema::flags (), this),
    stationName_ (::xml_schema::flags (), this)
  {
  }

  acquisitionSystemInformationType::
  acquisitionSystemInformationType (const acquisitionSystemInformationType& x,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    systemVendor_ (x.systemVendor_, f, this),
    systemModel_ (x.systemModel_, f, this),
    systemFieldStrength_T_ (x.systemFieldStrength_T_, f, this),
    relativeReceiverNoiseBandwidth_ (x.relativeReceiverNoiseBandwidth_, f, this),
    receiverChannels_ (x.receiverChannels_, f, this),
    institutionName_ (x.institutionName_, f, this),
    stationName_ (x.stationName_, f, this)
  {
  }

  acquisitionSystemInformationType::
  acquisitionSystemInformationType (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f,
                                    ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    systemVendor_ (f, this),
    systemModel_ (f, this),
    systemFieldStrength_T_ (f, this),
    relativeReceiverNoiseBandwidth_ (f, this),
    receiverChannels_ (f, this),
    institutionName_ (f, this),
    stationName_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void acquisitionSystemInformationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // systemVendor
      //
      if (n.name () == "systemVendor" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< systemVendor_type > r (
          systemVendor_traits::create (i, f, this));

        if (!this->systemVendor_)
        {
          this->systemVendor_.set (r);
          continue;
        }
      }

      // systemModel
      //
      if (n.name () == "systemModel" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< systemModel_type > r (
          systemModel_traits::create (i, f, this));

        if (!this->systemModel_)
        {
          this->systemModel_.set (r);
          continue;
        }
      }

      // systemFieldStrength_T
      //
      if (n.name () == "systemFieldStrength_T" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->systemFieldStrength_T_)
        {
          this->systemFieldStrength_T_.set (systemFieldStrength_T_traits::create (i, f, this));
          continue;
        }
      }

      // relativeReceiverNoiseBandwidth
      //
      if (n.name () == "relativeReceiverNoiseBandwidth" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->relativeReceiverNoiseBandwidth_)
        {
          this->relativeReceiverNoiseBandwidth_.set (relativeReceiverNoiseBandwidth_traits::create (i, f, this));
          continue;
        }
      }

      // receiverChannels
      //
      if (n.name () == "receiverChannels" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->receiverChannels_)
        {
          this->receiverChannels_.set (receiverChannels_traits::create (i, f, this));
          continue;
        }
      }

      // institutionName
      //
      if (n.name () == "institutionName" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< institutionName_type > r (
          institutionName_traits::create (i, f, this));

        if (!this->institutionName_)
        {
          this->institutionName_.set (r);
          continue;
        }
      }

      // stationName
      //
      if (n.name () == "stationName" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< stationName_type > r (
          stationName_traits::create (i, f, this));

        if (!this->stationName_)
        {
          this->stationName_.set (r);
          continue;
        }
      }

      break;
    }
  }

  acquisitionSystemInformationType* acquisitionSystemInformationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class acquisitionSystemInformationType (*this, f, c);
  }

  acquisitionSystemInformationType::
  ~acquisitionSystemInformationType ()
  {
  }

  // experimentalConditionsType
  //

  experimentalConditionsType::
  experimentalConditionsType (const H1resonanceFrequency_Hz_type& H1resonanceFrequency_Hz)
  : ::xml_schema::type (),
    H1resonanceFrequency_Hz_ (H1resonanceFrequency_Hz, ::xml_schema::flags (), this)
  {
  }

  experimentalConditionsType::
  experimentalConditionsType (const experimentalConditionsType& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    H1resonanceFrequency_Hz_ (x.H1resonanceFrequency_Hz_, f, this)
  {
  }

  experimentalConditionsType::
  experimentalConditionsType (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    H1resonanceFrequency_Hz_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void experimentalConditionsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // H1resonanceFrequency_Hz
      //
      if (n.name () == "H1resonanceFrequency_Hz" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!H1resonanceFrequency_Hz_.present ())
        {
          this->H1resonanceFrequency_Hz_.set (H1resonanceFrequency_Hz_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!H1resonanceFrequency_Hz_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "H1resonanceFrequency_Hz",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  experimentalConditionsType* experimentalConditionsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class experimentalConditionsType (*this, f, c);
  }

  experimentalConditionsType::
  ~experimentalConditionsType ()
  {
  }

  // encoding
  //

  encoding::
  encoding (const encodedSpace_type& encodedSpace,
            const reconSpace_type& reconSpace,
            const encodingLimits_type& encodingLimits,
            const trajectory_type& trajectory)
  : ::xml_schema::type (),
    encodedSpace_ (encodedSpace, ::xml_schema::flags (), this),
    reconSpace_ (reconSpace, ::xml_schema::flags (), this),
    encodingLimits_ (encodingLimits, ::xml_schema::flags (), this),
    trajectory_ (trajectory, ::xml_schema::flags (), this),
    trajectoryDescription_ (::xml_schema::flags (), this)
  {
  }

  encoding::
  encoding (::std::auto_ptr< encodedSpace_type >& encodedSpace,
            ::std::auto_ptr< reconSpace_type >& reconSpace,
            ::std::auto_ptr< encodingLimits_type >& encodingLimits,
            const trajectory_type& trajectory)
  : ::xml_schema::type (),
    encodedSpace_ (encodedSpace, ::xml_schema::flags (), this),
    reconSpace_ (reconSpace, ::xml_schema::flags (), this),
    encodingLimits_ (encodingLimits, ::xml_schema::flags (), this),
    trajectory_ (trajectory, ::xml_schema::flags (), this),
    trajectoryDescription_ (::xml_schema::flags (), this)
  {
  }

  encoding::
  encoding (const encoding& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    encodedSpace_ (x.encodedSpace_, f, this),
    reconSpace_ (x.reconSpace_, f, this),
    encodingLimits_ (x.encodingLimits_, f, this),
    trajectory_ (x.trajectory_, f, this),
    trajectoryDescription_ (x.trajectoryDescription_, f, this)
  {
  }

  encoding::
  encoding (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    encodedSpace_ (f, this),
    reconSpace_ (f, this),
    encodingLimits_ (f, this),
    trajectory_ (f, this),
    trajectoryDescription_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void encoding::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // encodedSpace
      //
      if (n.name () == "encodedSpace" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< encodedSpace_type > r (
          encodedSpace_traits::create (i, f, this));

        if (!encodedSpace_.present ())
        {
          this->encodedSpace_.set (r);
          continue;
        }
      }

      // reconSpace
      //
      if (n.name () == "reconSpace" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< reconSpace_type > r (
          reconSpace_traits::create (i, f, this));

        if (!reconSpace_.present ())
        {
          this->reconSpace_.set (r);
          continue;
        }
      }

      // encodingLimits
      //
      if (n.name () == "encodingLimits" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< encodingLimits_type > r (
          encodingLimits_traits::create (i, f, this));

        if (!encodingLimits_.present ())
        {
          this->encodingLimits_.set (r);
          continue;
        }
      }

      // trajectory
      //
      if (n.name () == "trajectory" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< trajectory_type > r (
          trajectory_traits::create (i, f, this));

        if (!trajectory_.present ())
        {
          this->trajectory_.set (r);
          continue;
        }
      }

      // trajectoryDescription
      //
      if (n.name () == "trajectoryDescription" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< trajectoryDescription_type > r (
          trajectoryDescription_traits::create (i, f, this));

        if (!this->trajectoryDescription_)
        {
          this->trajectoryDescription_.set (r);
          continue;
        }
      }

      break;
    }

    if (!encodedSpace_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "encodedSpace",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!reconSpace_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "reconSpace",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!encodingLimits_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "encodingLimits",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!trajectory_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "trajectory",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  encoding* encoding::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encoding (*this, f, c);
  }

  encoding::
  ~encoding ()
  {
  }

  // encodingSpaceType
  //

  encodingSpaceType::
  encodingSpaceType (const matrixSize_type& matrixSize,
                     const fieldOfView_mm_type& fieldOfView_mm)
  : ::xml_schema::type (),
    matrixSize_ (matrixSize, ::xml_schema::flags (), this),
    fieldOfView_mm_ (fieldOfView_mm, ::xml_schema::flags (), this)
  {
  }

  encodingSpaceType::
  encodingSpaceType (::std::auto_ptr< matrixSize_type >& matrixSize,
                     ::std::auto_ptr< fieldOfView_mm_type >& fieldOfView_mm)
  : ::xml_schema::type (),
    matrixSize_ (matrixSize, ::xml_schema::flags (), this),
    fieldOfView_mm_ (fieldOfView_mm, ::xml_schema::flags (), this)
  {
  }

  encodingSpaceType::
  encodingSpaceType (const encodingSpaceType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    matrixSize_ (x.matrixSize_, f, this),
    fieldOfView_mm_ (x.fieldOfView_mm_, f, this)
  {
  }

  encodingSpaceType::
  encodingSpaceType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    matrixSize_ (f, this),
    fieldOfView_mm_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void encodingSpaceType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // matrixSize
      //
      if (n.name () == "matrixSize" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< matrixSize_type > r (
          matrixSize_traits::create (i, f, this));

        if (!matrixSize_.present ())
        {
          this->matrixSize_.set (r);
          continue;
        }
      }

      // fieldOfView_mm
      //
      if (n.name () == "fieldOfView_mm" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< fieldOfView_mm_type > r (
          fieldOfView_mm_traits::create (i, f, this));

        if (!fieldOfView_mm_.present ())
        {
          this->fieldOfView_mm_.set (r);
          continue;
        }
      }

      break;
    }

    if (!matrixSize_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "matrixSize",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!fieldOfView_mm_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "fieldOfView_mm",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  encodingSpaceType* encodingSpaceType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encodingSpaceType (*this, f, c);
  }

  encodingSpaceType::
  ~encodingSpaceType ()
  {
  }

  // matrixSize
  //

  matrixSize::
  matrixSize (const x_type& x,
              const y_type& y,
              const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  matrixSize::
  matrixSize (const matrixSize& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  matrixSize::
  matrixSize (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void matrixSize::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!z_.present ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  matrixSize* matrixSize::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class matrixSize (*this, f, c);
  }

  matrixSize::
  ~matrixSize ()
  {
  }

  // fieldOfView_mm
  //

  fieldOfView_mm::
  fieldOfView_mm (const x_type& x,
                  const y_type& y,
                  const z_type& z)
  : ::xml_schema::type (),
    x_ (x, ::xml_schema::flags (), this),
    y_ (y, ::xml_schema::flags (), this),
    z_ (z, ::xml_schema::flags (), this)
  {
  }

  fieldOfView_mm::
  fieldOfView_mm (const fieldOfView_mm& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    x_ (x.x_, f, this),
    y_ (x.y_, f, this),
    z_ (x.z_, f, this)
  {
  }

  fieldOfView_mm::
  fieldOfView_mm (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    x_ (f, this),
    y_ (f, this),
    z_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void fieldOfView_mm::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // x
      //
      if (n.name () == "x" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!x_.present ())
        {
          this->x_.set (x_traits::create (i, f, this));
          continue;
        }
      }

      // y
      //
      if (n.name () == "y" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!y_.present ())
        {
          this->y_.set (y_traits::create (i, f, this));
          continue;
        }
      }

      // z
      //
      if (n.name () == "z" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!z_.present ())
        {
          this->z_.set (z_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!x_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "x",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!y_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "y",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!z_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "z",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  fieldOfView_mm* fieldOfView_mm::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class fieldOfView_mm (*this, f, c);
  }

  fieldOfView_mm::
  ~fieldOfView_mm ()
  {
  }

  // limitType
  //

  limitType::
  limitType (const minimum_type& minimum,
             const maximum_type& maximum,
             const center_type& center)
  : ::xml_schema::type (),
    minimum_ (minimum, ::xml_schema::flags (), this),
    maximum_ (maximum, ::xml_schema::flags (), this),
    center_ (center, ::xml_schema::flags (), this)
  {
  }

  limitType::
  limitType (const limitType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    minimum_ (x.minimum_, f, this),
    maximum_ (x.maximum_, f, this),
    center_ (x.center_, f, this)
  {
  }

  limitType::
  limitType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    minimum_ (f, this),
    maximum_ (f, this),
    center_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void limitType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // minimum
      //
      if (n.name () == "minimum" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!minimum_.present ())
        {
          this->minimum_.set (minimum_traits::create (i, f, this));
          continue;
        }
      }

      // maximum
      //
      if (n.name () == "maximum" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!maximum_.present ())
        {
          this->maximum_.set (maximum_traits::create (i, f, this));
          continue;
        }
      }

      // center
      //
      if (n.name () == "center" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!center_.present ())
        {
          this->center_.set (center_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!minimum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "minimum",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!maximum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maximum",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!center_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "center",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  limitType* limitType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class limitType (*this, f, c);
  }

  limitType::
  ~limitType ()
  {
  }

  // encodingLimitsType
  //

  encodingLimitsType::
  encodingLimitsType ()
  : ::xml_schema::type (),
    kspace_encoding_step_0_ (::xml_schema::flags (), this),
    kspace_encoding_step_1_ (::xml_schema::flags (), this),
    kspace_encoding_step_2_ (::xml_schema::flags (), this),
    average_ (::xml_schema::flags (), this),
    slice_ (::xml_schema::flags (), this),
    contrast_ (::xml_schema::flags (), this),
    phase_ (::xml_schema::flags (), this),
    repetition_ (::xml_schema::flags (), this),
    set_ (::xml_schema::flags (), this),
    segment_ (::xml_schema::flags (), this)
  {
  }

  encodingLimitsType::
  encodingLimitsType (const encodingLimitsType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    kspace_encoding_step_0_ (x.kspace_encoding_step_0_, f, this),
    kspace_encoding_step_1_ (x.kspace_encoding_step_1_, f, this),
    kspace_encoding_step_2_ (x.kspace_encoding_step_2_, f, this),
    average_ (x.average_, f, this),
    slice_ (x.slice_, f, this),
    contrast_ (x.contrast_, f, this),
    phase_ (x.phase_, f, this),
    repetition_ (x.repetition_, f, this),
    set_ (x.set_, f, this),
    segment_ (x.segment_, f, this)
  {
  }

  encodingLimitsType::
  encodingLimitsType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    kspace_encoding_step_0_ (f, this),
    kspace_encoding_step_1_ (f, this),
    kspace_encoding_step_2_ (f, this),
    average_ (f, this),
    slice_ (f, this),
    contrast_ (f, this),
    phase_ (f, this),
    repetition_ (f, this),
    set_ (f, this),
    segment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void encodingLimitsType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // kspace_encoding_step_0
      //
      if (n.name () == "kspace_encoding_step_0" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< kspace_encoding_step_0_type > r (
          kspace_encoding_step_0_traits::create (i, f, this));

        if (!this->kspace_encoding_step_0_)
        {
          this->kspace_encoding_step_0_.set (r);
          continue;
        }
      }

      // kspace_encoding_step_1
      //
      if (n.name () == "kspace_encoding_step_1" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< kspace_encoding_step_1_type > r (
          kspace_encoding_step_1_traits::create (i, f, this));

        if (!this->kspace_encoding_step_1_)
        {
          this->kspace_encoding_step_1_.set (r);
          continue;
        }
      }

      // kspace_encoding_step_2
      //
      if (n.name () == "kspace_encoding_step_2" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< kspace_encoding_step_2_type > r (
          kspace_encoding_step_2_traits::create (i, f, this));

        if (!this->kspace_encoding_step_2_)
        {
          this->kspace_encoding_step_2_.set (r);
          continue;
        }
      }

      // average
      //
      if (n.name () == "average" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< average_type > r (
          average_traits::create (i, f, this));

        if (!this->average_)
        {
          this->average_.set (r);
          continue;
        }
      }

      // slice
      //
      if (n.name () == "slice" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< slice_type > r (
          slice_traits::create (i, f, this));

        if (!this->slice_)
        {
          this->slice_.set (r);
          continue;
        }
      }

      // contrast
      //
      if (n.name () == "contrast" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< contrast_type > r (
          contrast_traits::create (i, f, this));

        if (!this->contrast_)
        {
          this->contrast_.set (r);
          continue;
        }
      }

      // phase
      //
      if (n.name () == "phase" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< phase_type > r (
          phase_traits::create (i, f, this));

        if (!this->phase_)
        {
          this->phase_.set (r);
          continue;
        }
      }

      // repetition
      //
      if (n.name () == "repetition" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< repetition_type > r (
          repetition_traits::create (i, f, this));

        if (!this->repetition_)
        {
          this->repetition_.set (r);
          continue;
        }
      }

      // set
      //
      if (n.name () == "set" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< set_type > r (
          set_traits::create (i, f, this));

        if (!this->set_)
        {
          this->set_.set (r);
          continue;
        }
      }

      // segment
      //
      if (n.name () == "segment" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< segment_type > r (
          segment_traits::create (i, f, this));

        if (!this->segment_)
        {
          this->segment_.set (r);
          continue;
        }
      }

      break;
    }
  }

  encodingLimitsType* encodingLimitsType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class encodingLimitsType (*this, f, c);
  }

  encodingLimitsType::
  ~encodingLimitsType ()
  {
  }

  // trajectoryType
  //

  trajectoryType::
  trajectoryType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_trajectoryType_convert ();
  }

  trajectoryType::
  trajectoryType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_trajectoryType_convert ();
  }

  trajectoryType::
  trajectoryType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_trajectoryType_convert ();
  }

  trajectoryType* trajectoryType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class trajectoryType (*this, f, c);
  }

  trajectoryType::value trajectoryType::
  _xsd_trajectoryType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_trajectoryType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_trajectoryType_indexes_,
                      _xsd_trajectoryType_indexes_ + 6,
                      *this,
                      c));

    if (i == _xsd_trajectoryType_indexes_ + 6 || _xsd_trajectoryType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const trajectoryType::
  _xsd_trajectoryType_literals_[6] =
  {
    "cartesian",
    "epi",
    "radial",
    "goldenangle",
    "spiral",
    "other"
  };

  const trajectoryType::value trajectoryType::
  _xsd_trajectoryType_indexes_[6] =
  {
    ::ISMRMRD::trajectoryType::cartesian,
    ::ISMRMRD::trajectoryType::epi,
    ::ISMRMRD::trajectoryType::goldenangle,
    ::ISMRMRD::trajectoryType::other,
    ::ISMRMRD::trajectoryType::radial,
    ::ISMRMRD::trajectoryType::spiral
  };

  // trajectoryDescriptionType
  //

  trajectoryDescriptionType::
  trajectoryDescriptionType (const identifier_type& identifier)
  : ::xml_schema::type (),
    identifier_ (identifier, ::xml_schema::flags (), this),
    userParameterLong_ (::xml_schema::flags (), this),
    userParameterDouble_ (::xml_schema::flags (), this),
    comment_ (::xml_schema::flags (), this)
  {
  }

  trajectoryDescriptionType::
  trajectoryDescriptionType (const trajectoryDescriptionType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    identifier_ (x.identifier_, f, this),
    userParameterLong_ (x.userParameterLong_, f, this),
    userParameterDouble_ (x.userParameterDouble_, f, this),
    comment_ (x.comment_, f, this)
  {
  }

  trajectoryDescriptionType::
  trajectoryDescriptionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    identifier_ (f, this),
    userParameterLong_ (f, this),
    userParameterDouble_ (f, this),
    comment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void trajectoryDescriptionType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // identifier
      //
      if (n.name () == "identifier" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< identifier_type > r (
          identifier_traits::create (i, f, this));

        if (!identifier_.present ())
        {
          this->identifier_.set (r);
          continue;
        }
      }

      // userParameterLong
      //
      if (n.name () == "userParameterLong" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterLong_type > r (
          userParameterLong_traits::create (i, f, this));

        this->userParameterLong_.push_back (r);
        continue;
      }

      // userParameterDouble
      //
      if (n.name () == "userParameterDouble" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterDouble_type > r (
          userParameterDouble_traits::create (i, f, this));

        this->userParameterDouble_.push_back (r);
        continue;
      }

      // comment
      //
      if (n.name () == "comment" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< comment_type > r (
          comment_traits::create (i, f, this));

        if (!this->comment_)
        {
          this->comment_.set (r);
          continue;
        }
      }

      break;
    }

    if (!identifier_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "identifier",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  trajectoryDescriptionType* trajectoryDescriptionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class trajectoryDescriptionType (*this, f, c);
  }

  trajectoryDescriptionType::
  ~trajectoryDescriptionType ()
  {
  }

  // sequenceParametersType
  //

  sequenceParametersType::
  sequenceParametersType ()
  : ::xml_schema::type (),
    TR_ (::xml_schema::flags (), this),
    TE_ (::xml_schema::flags (), this),
    TI_ (::xml_schema::flags (), this)
  {
  }

  sequenceParametersType::
  sequenceParametersType (const sequenceParametersType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TR_ (x.TR_, f, this),
    TE_ (x.TE_, f, this),
    TI_ (x.TI_, f, this)
  {
  }

  sequenceParametersType::
  sequenceParametersType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TR_ (f, this),
    TE_ (f, this),
    TI_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void sequenceParametersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TR
      //
      if (n.name () == "TR" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        this->TR_.push_back (TR_traits::create (i, f, this));
        continue;
      }

      // TE
      //
      if (n.name () == "TE" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        this->TE_.push_back (TE_traits::create (i, f, this));
        continue;
      }

      // TI
      //
      if (n.name () == "TI" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        this->TI_.push_back (TI_traits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  sequenceParametersType* sequenceParametersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class sequenceParametersType (*this, f, c);
  }

  sequenceParametersType::
  ~sequenceParametersType ()
  {
  }

  // userParameterLongType
  //

  userParameterLongType::
  userParameterLongType (const name_type& name,
                         const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  userParameterLongType::
  userParameterLongType (const userParameterLongType& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  userParameterLongType::
  userParameterLongType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameterLongType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  userParameterLongType* userParameterLongType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameterLongType (*this, f, c);
  }

  userParameterLongType::
  ~userParameterLongType ()
  {
  }

  // userParameterDoubleType
  //

  userParameterDoubleType::
  userParameterDoubleType (const name_type& name,
                           const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  userParameterDoubleType::
  userParameterDoubleType (const userParameterDoubleType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  userParameterDoubleType::
  userParameterDoubleType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameterDoubleType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!value_.present ())
        {
          this->value_.set (value_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  userParameterDoubleType* userParameterDoubleType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameterDoubleType (*this, f, c);
  }

  userParameterDoubleType::
  ~userParameterDoubleType ()
  {
  }

  // userParameterStringType
  //

  userParameterStringType::
  userParameterStringType (const name_type& name,
                           const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  userParameterStringType::
  userParameterStringType (const userParameterStringType& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  userParameterStringType::
  userParameterStringType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameterStringType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  userParameterStringType* userParameterStringType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameterStringType (*this, f, c);
  }

  userParameterStringType::
  ~userParameterStringType ()
  {
  }

  // userParameterBase64Type
  //

  userParameterBase64Type::
  userParameterBase64Type (const name_type& name,
                           const value_type& value)
  : ::xml_schema::type (),
    name_ (name, ::xml_schema::flags (), this),
    value_ (value, ::xml_schema::flags (), this)
  {
  }

  userParameterBase64Type::
  userParameterBase64Type (const userParameterBase64Type& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  userParameterBase64Type::
  userParameterBase64Type (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    name_ (f, this),
    value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameterBase64Type::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // name
      //
      if (n.name () == "name" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< name_type > r (
          name_traits::create (i, f, this));

        if (!name_.present ())
        {
          this->name_.set (r);
          continue;
        }
      }

      // value
      //
      if (n.name () == "value" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< value_type > r (
          value_traits::create (i, f, this));

        if (!value_.present ())
        {
          this->value_.set (r);
          continue;
        }
      }

      break;
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "name",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "value",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  userParameterBase64Type* userParameterBase64Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameterBase64Type (*this, f, c);
  }

  userParameterBase64Type::
  ~userParameterBase64Type ()
  {
  }

  // dicomParametersType
  //

  dicomParametersType::
  dicomParametersType (const studyInstanceUID_type& studyInstanceUID)
  : ::xml_schema::type (),
    studyInstanceUID_ (studyInstanceUID, ::xml_schema::flags (), this),
    seriesInstanceUIDRoot_ (::xml_schema::flags (), this),
    frameOfReferenceUID_ (::xml_schema::flags (), this),
    referencedImageSequence_ (::xml_schema::flags (), this),
    MRImageModule_ (::xml_schema::flags (), this)
  {
  }

  dicomParametersType::
  dicomParametersType (const dicomParametersType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    studyInstanceUID_ (x.studyInstanceUID_, f, this),
    seriesInstanceUIDRoot_ (x.seriesInstanceUIDRoot_, f, this),
    frameOfReferenceUID_ (x.frameOfReferenceUID_, f, this),
    referencedImageSequence_ (x.referencedImageSequence_, f, this),
    MRImageModule_ (x.MRImageModule_, f, this)
  {
  }

  dicomParametersType::
  dicomParametersType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    studyInstanceUID_ (f, this),
    seriesInstanceUIDRoot_ (f, this),
    frameOfReferenceUID_ (f, this),
    referencedImageSequence_ (f, this),
    MRImageModule_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void dicomParametersType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // studyInstanceUID
      //
      if (n.name () == "studyInstanceUID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< studyInstanceUID_type > r (
          studyInstanceUID_traits::create (i, f, this));

        if (!studyInstanceUID_.present ())
        {
          this->studyInstanceUID_.set (r);
          continue;
        }
      }

      // seriesInstanceUIDRoot
      //
      if (n.name () == "seriesInstanceUIDRoot" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< seriesInstanceUIDRoot_type > r (
          seriesInstanceUIDRoot_traits::create (i, f, this));

        if (!this->seriesInstanceUIDRoot_)
        {
          this->seriesInstanceUIDRoot_.set (r);
          continue;
        }
      }

      // frameOfReferenceUID
      //
      if (n.name () == "frameOfReferenceUID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< frameOfReferenceUID_type > r (
          frameOfReferenceUID_traits::create (i, f, this));

        if (!this->frameOfReferenceUID_)
        {
          this->frameOfReferenceUID_.set (r);
          continue;
        }
      }

      // referencedImageSequence
      //
      if (n.name () == "referencedImageSequence" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< referencedImageSequence_type > r (
          referencedImageSequence_traits::create (i, f, this));

        if (!this->referencedImageSequence_)
        {
          this->referencedImageSequence_.set (r);
          continue;
        }
      }

      // MRImageModule
      //
      if (n.name () == "MRImageModule" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< MRImageModule_type > r (
          MRImageModule_traits::create (i, f, this));

        if (!this->MRImageModule_)
        {
          this->MRImageModule_.set (r);
          continue;
        }
      }

      break;
    }

    if (!studyInstanceUID_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "studyInstanceUID",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  dicomParametersType* dicomParametersType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class dicomParametersType (*this, f, c);
  }

  dicomParametersType::
  ~dicomParametersType ()
  {
  }

  // referencedImageSequence
  //

  referencedImageSequence::
  referencedImageSequence ()
  : ::xml_schema::type (),
    referencedSOPInstanceUID_ (::xml_schema::flags (), this)
  {
  }

  referencedImageSequence::
  referencedImageSequence (const referencedImageSequence& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    referencedSOPInstanceUID_ (x.referencedSOPInstanceUID_, f, this)
  {
  }

  referencedImageSequence::
  referencedImageSequence (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    referencedSOPInstanceUID_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void referencedImageSequence::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // referencedSOPInstanceUID
      //
      if (n.name () == "referencedSOPInstanceUID" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< referencedSOPInstanceUID_type > r (
          referencedSOPInstanceUID_traits::create (i, f, this));

        this->referencedSOPInstanceUID_.push_back (r);
        continue;
      }

      break;
    }
  }

  referencedImageSequence* referencedImageSequence::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class referencedImageSequence (*this, f, c);
  }

  referencedImageSequence::
  ~referencedImageSequence ()
  {
  }

  // MRImageModule
  //

  MRImageModule::
  MRImageModule ()
  : ::xml_schema::type (),
    imageType_ (::xml_schema::flags (), this),
    scanningSequence_ (::xml_schema::flags (), this),
    sequenceVariant_ (::xml_schema::flags (), this),
    scanOptions_ (::xml_schema::flags (), this),
    mrAcquisitionType_ (::xml_schema::flags (), this),
    echoTrainLength_ (::xml_schema::flags (), this),
    triggerTime_ (::xml_schema::flags (), this),
    flipAngle_deg_ (::xml_schema::flags (), this),
    freqEncodingDirection_ (::xml_schema::flags (), this)
  {
  }

  MRImageModule::
  MRImageModule (const MRImageModule& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    imageType_ (x.imageType_, f, this),
    scanningSequence_ (x.scanningSequence_, f, this),
    sequenceVariant_ (x.sequenceVariant_, f, this),
    scanOptions_ (x.scanOptions_, f, this),
    mrAcquisitionType_ (x.mrAcquisitionType_, f, this),
    echoTrainLength_ (x.echoTrainLength_, f, this),
    triggerTime_ (x.triggerTime_, f, this),
    flipAngle_deg_ (x.flipAngle_deg_, f, this),
    freqEncodingDirection_ (x.freqEncodingDirection_, f, this)
  {
  }

  MRImageModule::
  MRImageModule (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    imageType_ (f, this),
    scanningSequence_ (f, this),
    sequenceVariant_ (f, this),
    scanOptions_ (f, this),
    mrAcquisitionType_ (f, this),
    echoTrainLength_ (f, this),
    triggerTime_ (f, this),
    flipAngle_deg_ (f, this),
    freqEncodingDirection_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void MRImageModule::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // imageType
      //
      if (n.name () == "imageType" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< imageType_type > r (
          imageType_traits::create (i, f, this));

        if (!this->imageType_)
        {
          this->imageType_.set (r);
          continue;
        }
      }

      // scanningSequence
      //
      if (n.name () == "scanningSequence" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< scanningSequence_type > r (
          scanningSequence_traits::create (i, f, this));

        if (!this->scanningSequence_)
        {
          this->scanningSequence_.set (r);
          continue;
        }
      }

      // sequenceVariant
      //
      if (n.name () == "sequenceVariant" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< sequenceVariant_type > r (
          sequenceVariant_traits::create (i, f, this));

        if (!this->sequenceVariant_)
        {
          this->sequenceVariant_.set (r);
          continue;
        }
      }

      // scanOptions
      //
      if (n.name () == "scanOptions" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< scanOptions_type > r (
          scanOptions_traits::create (i, f, this));

        if (!this->scanOptions_)
        {
          this->scanOptions_.set (r);
          continue;
        }
      }

      // mrAcquisitionType
      //
      if (n.name () == "mrAcquisitionType" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< mrAcquisitionType_type > r (
          mrAcquisitionType_traits::create (i, f, this));

        if (!this->mrAcquisitionType_)
        {
          this->mrAcquisitionType_.set (r);
          continue;
        }
      }

      // echoTrainLength
      //
      if (n.name () == "echoTrainLength" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->echoTrainLength_)
        {
          this->echoTrainLength_.set (echoTrainLength_traits::create (i, f, this));
          continue;
        }
      }

      // triggerTime
      //
      if (n.name () == "triggerTime" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->triggerTime_)
        {
          this->triggerTime_.set (triggerTime_traits::create (i, f, this));
          continue;
        }
      }

      // flipAngle_deg
      //
      if (n.name () == "flipAngle_deg" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!this->flipAngle_deg_)
        {
          this->flipAngle_deg_.set (flipAngle_deg_traits::create (i, f, this));
          continue;
        }
      }

      // freqEncodingDirection
      //
      if (n.name () == "freqEncodingDirection" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< freqEncodingDirection_type > r (
          freqEncodingDirection_traits::create (i, f, this));

        if (!this->freqEncodingDirection_)
        {
          this->freqEncodingDirection_.set (r);
          continue;
        }
      }

      break;
    }
  }

  MRImageModule* MRImageModule::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class MRImageModule (*this, f, c);
  }

  MRImageModule::
  ~MRImageModule ()
  {
  }

  // userParameters
  //

  userParameters::
  userParameters ()
  : ::xml_schema::type (),
    userParameterLong_ (::xml_schema::flags (), this),
    userParameterDouble_ (::xml_schema::flags (), this),
    userParameterString_ (::xml_schema::flags (), this),
    userParameterBase64_ (::xml_schema::flags (), this)
  {
  }

  userParameters::
  userParameters (const userParameters& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    userParameterLong_ (x.userParameterLong_, f, this),
    userParameterDouble_ (x.userParameterDouble_, f, this),
    userParameterString_ (x.userParameterString_, f, this),
    userParameterBase64_ (x.userParameterBase64_, f, this)
  {
  }

  userParameters::
  userParameters (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    userParameterLong_ (f, this),
    userParameterDouble_ (f, this),
    userParameterString_ (f, this),
    userParameterBase64_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void userParameters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // userParameterLong
      //
      if (n.name () == "userParameterLong" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterLong_type > r (
          userParameterLong_traits::create (i, f, this));

        this->userParameterLong_.push_back (r);
        continue;
      }

      // userParameterDouble
      //
      if (n.name () == "userParameterDouble" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterDouble_type > r (
          userParameterDouble_traits::create (i, f, this));

        this->userParameterDouble_.push_back (r);
        continue;
      }

      // userParameterString
      //
      if (n.name () == "userParameterString" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterString_type > r (
          userParameterString_traits::create (i, f, this));

        this->userParameterString_.push_back (r);
        continue;
      }

      // userParameterBase64
      //
      if (n.name () == "userParameterBase64" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< userParameterBase64_type > r (
          userParameterBase64_traits::create (i, f, this));

        this->userParameterBase64_.push_back (r);
        continue;
      }

      break;
    }
  }

  userParameters* userParameters::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class userParameters (*this, f, c);
  }

  userParameters::
  ~userParameters ()
  {
  }

  // accelerationFactorType
  //

  accelerationFactorType::
  accelerationFactorType (const kspace_encoding_step_1_type& kspace_encoding_step_1,
                          const kspace_encoding_step_2_type& kspace_encoding_step_2)
  : ::xml_schema::type (),
    kspace_encoding_step_1_ (kspace_encoding_step_1, ::xml_schema::flags (), this),
    kspace_encoding_step_2_ (kspace_encoding_step_2, ::xml_schema::flags (), this)
  {
  }

  accelerationFactorType::
  accelerationFactorType (const accelerationFactorType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    kspace_encoding_step_1_ (x.kspace_encoding_step_1_, f, this),
    kspace_encoding_step_2_ (x.kspace_encoding_step_2_, f, this)
  {
  }

  accelerationFactorType::
  accelerationFactorType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    kspace_encoding_step_1_ (f, this),
    kspace_encoding_step_2_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void accelerationFactorType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // kspace_encoding_step_1
      //
      if (n.name () == "kspace_encoding_step_1" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!kspace_encoding_step_1_.present ())
        {
          this->kspace_encoding_step_1_.set (kspace_encoding_step_1_traits::create (i, f, this));
          continue;
        }
      }

      // kspace_encoding_step_2
      //
      if (n.name () == "kspace_encoding_step_2" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        if (!kspace_encoding_step_2_.present ())
        {
          this->kspace_encoding_step_2_.set (kspace_encoding_step_2_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!kspace_encoding_step_1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "kspace_encoding_step_1",
        "http://www.ismrm.org/ISMRMRD");
    }

    if (!kspace_encoding_step_2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "kspace_encoding_step_2",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  accelerationFactorType* accelerationFactorType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class accelerationFactorType (*this, f, c);
  }

  accelerationFactorType::
  ~accelerationFactorType ()
  {
  }

  // calibrationModeType
  //

  calibrationModeType::
  calibrationModeType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_calibrationModeType_convert ();
  }

  calibrationModeType::
  calibrationModeType (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_calibrationModeType_convert ();
  }

  calibrationModeType::
  calibrationModeType (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_calibrationModeType_convert ();
  }

  calibrationModeType* calibrationModeType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class calibrationModeType (*this, f, c);
  }

  calibrationModeType::value calibrationModeType::
  _xsd_calibrationModeType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_calibrationModeType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_calibrationModeType_indexes_,
                      _xsd_calibrationModeType_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_calibrationModeType_indexes_ + 5 || _xsd_calibrationModeType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const calibrationModeType::
  _xsd_calibrationModeType_literals_[5] =
  {
    "embedded",
    "interleaved",
    "separate",
    "external",
    "other"
  };

  const calibrationModeType::value calibrationModeType::
  _xsd_calibrationModeType_indexes_[5] =
  {
    ::ISMRMRD::calibrationModeType::embedded,
    ::ISMRMRD::calibrationModeType::external,
    ::ISMRMRD::calibrationModeType::interleaved,
    ::ISMRMRD::calibrationModeType::other,
    ::ISMRMRD::calibrationModeType::separate
  };

  // interleavingDimensionType
  //

  interleavingDimensionType::
  interleavingDimensionType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_interleavingDimensionType_convert ();
  }

  interleavingDimensionType::
  interleavingDimensionType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_interleavingDimensionType_convert ();
  }

  interleavingDimensionType::
  interleavingDimensionType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_interleavingDimensionType_convert ();
  }

  interleavingDimensionType* interleavingDimensionType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class interleavingDimensionType (*this, f, c);
  }

  interleavingDimensionType::value interleavingDimensionType::
  _xsd_interleavingDimensionType_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_interleavingDimensionType_literals_);
    const value* i (::std::lower_bound (
                      _xsd_interleavingDimensionType_indexes_,
                      _xsd_interleavingDimensionType_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_interleavingDimensionType_indexes_ + 5 || _xsd_interleavingDimensionType_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const interleavingDimensionType::
  _xsd_interleavingDimensionType_literals_[5] =
  {
    "phase",
    "repetition",
    "contrast",
    "average",
    "other"
  };

  const interleavingDimensionType::value interleavingDimensionType::
  _xsd_interleavingDimensionType_indexes_[5] =
  {
    ::ISMRMRD::interleavingDimensionType::average,
    ::ISMRMRD::interleavingDimensionType::contrast,
    ::ISMRMRD::interleavingDimensionType::other,
    ::ISMRMRD::interleavingDimensionType::phase,
    ::ISMRMRD::interleavingDimensionType::repetition
  };

  // parallelImagingType
  //

  parallelImagingType::
  parallelImagingType (const accelerationFactor_type& accelerationFactor)
  : ::xml_schema::type (),
    accelerationFactor_ (accelerationFactor, ::xml_schema::flags (), this),
    calibrationMode_ (::xml_schema::flags (), this),
    interleavingDimension_ (::xml_schema::flags (), this)
  {
  }

  parallelImagingType::
  parallelImagingType (::std::auto_ptr< accelerationFactor_type >& accelerationFactor)
  : ::xml_schema::type (),
    accelerationFactor_ (accelerationFactor, ::xml_schema::flags (), this),
    calibrationMode_ (::xml_schema::flags (), this),
    interleavingDimension_ (::xml_schema::flags (), this)
  {
  }

  parallelImagingType::
  parallelImagingType (const parallelImagingType& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    accelerationFactor_ (x.accelerationFactor_, f, this),
    calibrationMode_ (x.calibrationMode_, f, this),
    interleavingDimension_ (x.interleavingDimension_, f, this)
  {
  }

  parallelImagingType::
  parallelImagingType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    accelerationFactor_ (f, this),
    calibrationMode_ (f, this),
    interleavingDimension_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void parallelImagingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accelerationFactor
      //
      if (n.name () == "accelerationFactor" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< accelerationFactor_type > r (
          accelerationFactor_traits::create (i, f, this));

        if (!accelerationFactor_.present ())
        {
          this->accelerationFactor_.set (r);
          continue;
        }
      }

      // calibrationMode
      //
      if (n.name () == "calibrationMode" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< calibrationMode_type > r (
          calibrationMode_traits::create (i, f, this));

        if (!this->calibrationMode_)
        {
          this->calibrationMode_.set (r);
          continue;
        }
      }

      // interleavingDimension
      //
      if (n.name () == "interleavingDimension" && n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
      {
        ::std::auto_ptr< interleavingDimension_type > r (
          interleavingDimension_traits::create (i, f, this));

        if (!this->interleavingDimension_)
        {
          this->interleavingDimension_.set (r);
          continue;
        }
      }

      break;
    }

    if (!accelerationFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "accelerationFactor",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  parallelImagingType* parallelImagingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class parallelImagingType (*this, f, c);
  }

  parallelImagingType::
  ~parallelImagingType ()
  {
  }

  // patientGender
  //

  patientGender::
  patientGender ()
  : ::xml_schema::string ()
  {
  }

  patientGender::
  patientGender (const char* _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  patientGender::
  patientGender (const ::std::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  patientGender::
  patientGender (const ::xml_schema::string& _xsd_string_base)
  : ::xml_schema::string (_xsd_string_base)
  {
  }

  patientGender::
  patientGender (const patientGender& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (x, f, c)
  {
  }

  patientGender::
  patientGender (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
  }

  patientGender::
  patientGender (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
  }

  patientGender::
  patientGender (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
  }

  patientGender* patientGender::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class patientGender (*this, f, c);
  }

  patientGender::
  ~patientGender ()
  {
  }

  // patientPosition
  //

  patientPosition::
  patientPosition (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_patientPosition_convert ();
  }

  patientPosition::
  patientPosition (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_patientPosition_convert ();
  }

  patientPosition::
  patientPosition (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_patientPosition_convert ();
  }

  patientPosition* patientPosition::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class patientPosition (*this, f, c);
  }

  patientPosition::value patientPosition::
  _xsd_patientPosition_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_patientPosition_literals_);
    const value* i (::std::lower_bound (
                      _xsd_patientPosition_indexes_,
                      _xsd_patientPosition_indexes_ + 8,
                      *this,
                      c));

    if (i == _xsd_patientPosition_indexes_ + 8 || _xsd_patientPosition_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const patientPosition::
  _xsd_patientPosition_literals_[8] =
  {
    "HFP",
    "HFS",
    "HFDR",
    "HFDL",
    "FFP",
    "FFS",
    "FFDR",
    "FFDL"
  };

  const patientPosition::value patientPosition::
  _xsd_patientPosition_indexes_[8] =
  {
    ::ISMRMRD::patientPosition::FFDL,
    ::ISMRMRD::patientPosition::FFDR,
    ::ISMRMRD::patientPosition::FFP,
    ::ISMRMRD::patientPosition::FFS,
    ::ISMRMRD::patientPosition::HFDL,
    ::ISMRMRD::patientPosition::HFDR,
    ::ISMRMRD::patientPosition::HFP,
    ::ISMRMRD::patientPosition::HFS
  };

  // freqEncodingDirection
  //

  freqEncodingDirection::
  freqEncodingDirection (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_freqEncodingDirection_convert ();
  }

  freqEncodingDirection::
  freqEncodingDirection (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_freqEncodingDirection_convert ();
  }

  freqEncodingDirection::
  freqEncodingDirection (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_freqEncodingDirection_convert ();
  }

  freqEncodingDirection* freqEncodingDirection::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class freqEncodingDirection (*this, f, c);
  }

  freqEncodingDirection::value freqEncodingDirection::
  _xsd_freqEncodingDirection_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_freqEncodingDirection_literals_);
    const value* i (::std::lower_bound (
                      _xsd_freqEncodingDirection_indexes_,
                      _xsd_freqEncodingDirection_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_freqEncodingDirection_indexes_ + 2 || _xsd_freqEncodingDirection_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const freqEncodingDirection::
  _xsd_freqEncodingDirection_literals_[2] =
  {
    "ROW",
    "COL"
  };

  const freqEncodingDirection::value freqEncodingDirection::
  _xsd_freqEncodingDirection_indexes_[2] =
  {
    ::ISMRMRD::freqEncodingDirection::COL,
    ::ISMRMRD::freqEncodingDirection::ROW
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace ISMRMRD
{
  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::std::string& u,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::std::string& u,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::std::string& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::std::istream& is,
                  const ::std::string& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::ISMRMRD::ismrmrdHeader_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xercesc::InputSource& i,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xercesc::InputSource& i,
                  ::xml_schema::error_handler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xercesc::InputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
      ::ISMRMRD::ismrmrdHeader_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
        ::ISMRMRD::ismrmrdHeader_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ismrmrdHeader" &&
        n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
    {
      ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
        ::xsd::cxx::tree::traits< ::ISMRMRD::ismrmrdHeader, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ismrmrdHeader",
      "http://www.ismrm.org/ISMRMRD");
  }

  ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader >
  ismrmrdHeader_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                  ::xml_schema::flags f,
                  const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "ismrmrdHeader" &&
        n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
    {
      ::std::auto_ptr< ::ISMRMRD::ismrmrdHeader > r (
        ::xsd::cxx::tree::traits< ::ISMRMRD::ismrmrdHeader, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "ismrmrdHeader",
      "http://www.ismrm.org/ISMRMRD");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace ISMRMRD
{
  void
  ismrmrdHeader_ (::std::ostream& o,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ismrmrdHeader_ (::std::ostream& o,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::std::ostream& o,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::XMLFormatTarget& t,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::XMLFormatTarget& t,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xml_schema::error_handler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::XMLFormatTarget& t,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xercesc::DOMErrorHandler& h,
                  const ::xml_schema::namespace_infomap& m,
                  const ::std::string& e,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::ISMRMRD::ismrmrdHeader_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  ismrmrdHeader_ (::xercesc::DOMDocument& d,
                  const ::ISMRMRD::ismrmrdHeader& s,
                  ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "ismrmrdHeader" &&
        n.namespace_ () == "http://www.ismrm.org/ISMRMRD")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "ismrmrdHeader",
        "http://www.ismrm.org/ISMRMRD");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  ismrmrdHeader_ (const ::ISMRMRD::ismrmrdHeader& s,
                  const ::xml_schema::namespace_infomap& m,
                  ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ismrmrdHeader",
        "http://www.ismrm.org/ISMRMRD",
        m, f));

    ::ISMRMRD::ismrmrdHeader_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const ismrmrdHeader& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // subjectInformation
    //
    if (i.subjectInformation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "subjectInformation",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.subjectInformation ();
    }

    // studyInformation
    //
    if (i.studyInformation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "studyInformation",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.studyInformation ();
    }

    // measurementInformation
    //
    if (i.measurementInformation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "measurementInformation",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.measurementInformation ();
    }

    // acquisitionSystemInformation
    //
    if (i.acquisitionSystemInformation ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "acquisitionSystemInformation",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.acquisitionSystemInformation ();
    }

    // experimentalConditions
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "experimentalConditions",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.experimentalConditions ();
    }

    // encoding
    //
    for (ismrmrdHeader::encoding_const_iterator
         b (i.encoding ().begin ()), n (i.encoding ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encoding",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // parallelImaging
    //
    if (i.parallelImaging ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "parallelImaging",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.parallelImaging ();
    }

    // sequenceParameters
    //
    if (i.sequenceParameters ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequenceParameters",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.sequenceParameters ();
    }

    // dicomParameters
    //
    if (i.dicomParameters ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dicomParameters",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.dicomParameters ();
    }

    // userParameters
    //
    if (i.userParameters ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameters",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.userParameters ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const subjectInformationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // patientName
    //
    if (i.patientName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientName",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientName ();
    }

    // patientWeight_kg
    //
    if (i.patientWeight_kg ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientWeight_kg",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientWeight_kg ();
    }

    // patientID
    //
    if (i.patientID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientID ();
    }

    // patientBirthdate
    //
    if (i.patientBirthdate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientBirthdate",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientBirthdate ();
    }

    // patientGender
    //
    if (i.patientGender ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientGender",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.patientGender ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const studyInformationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // studyDate
    //
    if (i.studyDate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "studyDate",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.studyDate ();
    }

    // studyTime
    //
    if (i.studyTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "studyTime",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.studyTime ();
    }

    // studyID
    //
    if (i.studyID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "studyID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.studyID ();
    }

    // accessionNumber
    //
    if (i.accessionNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "accessionNumber",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.accessionNumber ();
    }

    // referringPhysicianName
    //
    if (i.referringPhysicianName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "referringPhysicianName",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.referringPhysicianName ();
    }

    // studyDescription
    //
    if (i.studyDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "studyDescription",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.studyDescription ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const measurementInformationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // measurementID
    //
    if (i.measurementID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "measurementID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.measurementID ();
    }

    // seriesDate
    //
    if (i.seriesDate ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "seriesDate",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.seriesDate ();
    }

    // seriesTime
    //
    if (i.seriesTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "seriesTime",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.seriesTime ();
    }

    // patientPosition
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "patientPosition",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.patientPosition ();
    }

    // initialSeriesNumber
    //
    if (i.initialSeriesNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "initialSeriesNumber",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.initialSeriesNumber ();
    }

    // protocolName
    //
    if (i.protocolName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "protocolName",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.protocolName ();
    }

    // seriesDescription
    //
    if (i.seriesDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "seriesDescription",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.seriesDescription ();
    }

    // measurementDependency
    //
    for (measurementInformationType::measurementDependency_const_iterator
         b (i.measurementDependency ().begin ()), n (i.measurementDependency ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "measurementDependency",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const measurementDependencyType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // dependencyType
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "dependencyType",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.dependencyType ();
    }

    // measurementID
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "measurementID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.measurementID ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const acquisitionSystemInformationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // systemVendor
    //
    if (i.systemVendor ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "systemVendor",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.systemVendor ();
    }

    // systemModel
    //
    if (i.systemModel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "systemModel",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.systemModel ();
    }

    // systemFieldStrength_T
    //
    if (i.systemFieldStrength_T ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "systemFieldStrength_T",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.systemFieldStrength_T ();
    }

    // relativeReceiverNoiseBandwidth
    //
    if (i.relativeReceiverNoiseBandwidth ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "relativeReceiverNoiseBandwidth",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.relativeReceiverNoiseBandwidth ();
    }

    // receiverChannels
    //
    if (i.receiverChannels ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "receiverChannels",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.receiverChannels ();
    }

    // institutionName
    //
    if (i.institutionName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "institutionName",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.institutionName ();
    }

    // stationName
    //
    if (i.stationName ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "stationName",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.stationName ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const experimentalConditionsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // H1resonanceFrequency_Hz
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "H1resonanceFrequency_Hz",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.H1resonanceFrequency_Hz ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encoding& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // encodedSpace
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encodedSpace",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.encodedSpace ();
    }

    // reconSpace
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "reconSpace",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.reconSpace ();
    }

    // encodingLimits
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "encodingLimits",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.encodingLimits ();
    }

    // trajectory
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trajectory",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.trajectory ();
    }

    // trajectoryDescription
    //
    if (i.trajectoryDescription ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "trajectoryDescription",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.trajectoryDescription ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encodingSpaceType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // matrixSize
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "matrixSize",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.matrixSize ();
    }

    // fieldOfView_mm
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "fieldOfView_mm",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.fieldOfView_mm ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const matrixSize& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.y ();
    }

    // z
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "z",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const fieldOfView_mm& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // x
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "x",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.x ();
    }

    // y
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "y",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.y ();
    }

    // z
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "z",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.z ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const limitType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // minimum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "minimum",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.minimum ();
    }

    // maximum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "maximum",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.maximum ();
    }

    // center
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "center",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.center ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const encodingLimitsType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // kspace_encoding_step_0
    //
    if (i.kspace_encoding_step_0 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_0",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.kspace_encoding_step_0 ();
    }

    // kspace_encoding_step_1
    //
    if (i.kspace_encoding_step_1 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_1",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.kspace_encoding_step_1 ();
    }

    // kspace_encoding_step_2
    //
    if (i.kspace_encoding_step_2 ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_2",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.kspace_encoding_step_2 ();
    }

    // average
    //
    if (i.average ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "average",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.average ();
    }

    // slice
    //
    if (i.slice ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "slice",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.slice ();
    }

    // contrast
    //
    if (i.contrast ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "contrast",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.contrast ();
    }

    // phase
    //
    if (i.phase ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "phase",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.phase ();
    }

    // repetition
    //
    if (i.repetition ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "repetition",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.repetition ();
    }

    // set
    //
    if (i.set ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "set",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.set ();
    }

    // segment
    //
    if (i.segment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "segment",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.segment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const trajectoryType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const trajectoryType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const trajectoryType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const trajectoryDescriptionType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // identifier
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "identifier",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.identifier ();
    }

    // userParameterLong
    //
    for (trajectoryDescriptionType::userParameterLong_const_iterator
         b (i.userParameterLong ().begin ()), n (i.userParameterLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterLong",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // userParameterDouble
    //
    for (trajectoryDescriptionType::userParameterDouble_const_iterator
         b (i.userParameterDouble ().begin ()), n (i.userParameterDouble ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterDouble",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // comment
    //
    if (i.comment ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "comment",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.comment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const sequenceParametersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TR
    //
    for (sequenceParametersType::TR_const_iterator
         b (i.TR ().begin ()), n (i.TR ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TR",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // TE
    //
    for (sequenceParametersType::TE_const_iterator
         b (i.TE ().begin ()), n (i.TE ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TE",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // TI
    //
    for (sequenceParametersType::TI_const_iterator
         b (i.TI ().begin ()), n (i.TI ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TI",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameterLongType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameterDoubleType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << ::xml_schema::as_double(i.value ());
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameterStringType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameterBase64Type& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // name
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "name",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.name ();
    }

    // value
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "value",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const dicomParametersType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // studyInstanceUID
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "studyInstanceUID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.studyInstanceUID ();
    }

    // seriesInstanceUIDRoot
    //
    if (i.seriesInstanceUIDRoot ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "seriesInstanceUIDRoot",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.seriesInstanceUIDRoot ();
    }

    // frameOfReferenceUID
    //
    if (i.frameOfReferenceUID ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "frameOfReferenceUID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.frameOfReferenceUID ();
    }

    // referencedImageSequence
    //
    if (i.referencedImageSequence ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "referencedImageSequence",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.referencedImageSequence ();
    }

    // MRImageModule
    //
    if (i.MRImageModule ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "MRImageModule",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.MRImageModule ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const referencedImageSequence& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // referencedSOPInstanceUID
    //
    for (referencedImageSequence::referencedSOPInstanceUID_const_iterator
         b (i.referencedSOPInstanceUID ().begin ()), n (i.referencedSOPInstanceUID ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "referencedSOPInstanceUID",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const MRImageModule& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // imageType
    //
    if (i.imageType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "imageType",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.imageType ();
    }

    // scanningSequence
    //
    if (i.scanningSequence ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scanningSequence",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.scanningSequence ();
    }

    // sequenceVariant
    //
    if (i.sequenceVariant ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "sequenceVariant",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.sequenceVariant ();
    }

    // scanOptions
    //
    if (i.scanOptions ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "scanOptions",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.scanOptions ();
    }

    // mrAcquisitionType
    //
    if (i.mrAcquisitionType ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "mrAcquisitionType",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.mrAcquisitionType ();
    }

    // echoTrainLength
    //
    if (i.echoTrainLength ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "echoTrainLength",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.echoTrainLength ();
    }

    // triggerTime
    //
    if (i.triggerTime ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "triggerTime",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.triggerTime ();
    }

    // flipAngle_deg
    //
    if (i.flipAngle_deg ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "flipAngle_deg",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.flipAngle_deg ();
    }

    // freqEncodingDirection
    //
    if (i.freqEncodingDirection ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "freqEncodingDirection",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.freqEncodingDirection ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const userParameters& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // userParameterLong
    //
    for (userParameters::userParameterLong_const_iterator
         b (i.userParameterLong ().begin ()), n (i.userParameterLong ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterLong",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // userParameterDouble
    //
    for (userParameters::userParameterDouble_const_iterator
         b (i.userParameterDouble ().begin ()), n (i.userParameterDouble ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterDouble",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // userParameterString
    //
    for (userParameters::userParameterString_const_iterator
         b (i.userParameterString ().begin ()), n (i.userParameterString ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterString",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }

    // userParameterBase64
    //
    for (userParameters::userParameterBase64_const_iterator
         b (i.userParameterBase64 ().begin ()), n (i.userParameterBase64 ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "userParameterBase64",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *b;
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const accelerationFactorType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // kspace_encoding_step_1
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_1",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.kspace_encoding_step_1 ();
    }

    // kspace_encoding_step_2
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "kspace_encoding_step_2",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.kspace_encoding_step_2 ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const calibrationModeType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const calibrationModeType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const calibrationModeType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const interleavingDimensionType& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const interleavingDimensionType& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const interleavingDimensionType& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const parallelImagingType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // accelerationFactor
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "accelerationFactor",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << i.accelerationFactor ();
    }

    // calibrationMode
    //
    if (i.calibrationMode ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "calibrationMode",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.calibrationMode ();
    }

    // interleavingDimension
    //
    if (i.interleavingDimension ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "interleavingDimension",
          "http://www.ismrm.org/ISMRMRD",
          e));

      s << *i.interleavingDimension ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const patientGender& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const patientGender& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const patientGender& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const patientPosition& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const patientPosition& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const patientPosition& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const freqEncodingDirection& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const freqEncodingDirection& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const freqEncodingDirection& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

